<!DOCTYPE html>
<html lang="en">
<head>
	<title></title>
	<link href="css/reset.css" rel="stylesheet">
	<link href="css/screen.css" rel="stylesheet">
</head>
<body>
	<div id="page">
		<div class="banner" role="banner">
			<h1>Epoxy.js: Elegant Data Binding for Backbone</h1>
		</div>
		<div class="navigation" role="navigation">
			<ul class="nav-main">
				<li><a href="index.html">About Epoxy</a></li>
				<li><a href="tutorial.html">Tutorial</a></li>
				<li class="active"><a href="doc.html">Documentation</a></li>
			</ul>
			<div class="nav-toc">
				<div class="nav-toc-content">
					<b><a href="#model">Epoxy.Model</a></b>
					<ul>
						<li><b><a href="#model-extend">extend</a></b></li>
						<li><b><a href="#model-constructor">constructor</a></b></li>
						<li><a href="#model-add-computed">addComputed</a></li>
						<li><a href="#model-add-observable">addObservable</a></li>
						<li><a href="#model-clear-observables">clearObservables</a></li>
						<li><a href="#model-computeds">computeds</a></li>
						<li><a href="#model-destroy">destroy</a></li>
						<li><a href="#model-get">get</a></li>
						<li><a href="#model-get-copy">getCopy</a></li>
						<li><a href="#model-has-observable">hasObservable</a></li>
						<li><a href="#model-modify-array">modifyArray</a></li>
						<li><a href="#model-modify-object">modifyObject</a></li>
						<li><a href="#model-observables">observables</a></li>
						<li><a href="#model-remove-observable">removeObservable</a></li>
						<li><a href="#model-set">set</a></li>
					</ul>
			
					<b><a href="#view">Epoxy.View</a></b>
					<ul>
						<li><b><a href="#view-extend">extend</a></b></li>
						<li><b><a href="#view-constructor">constructor</a></b></li>
						<li><b><a href="#view-context">binding context</a></b></li>
						<li><a href="#view-apply-bindings">applyBindings</a></li>
						<li><a href="#view-binding-handlers">bindingHandlers</a></li>
						<li><a href="#view-bindings">bindings</a></li>
						<li><a href="#view-remove">remove</a></li>
						<li><a href="#view-remove-bindings">removeBindings</a></li>
					</ul>
			
					<b><a href="#binding-handlers">View Binding Handlers</a></b>
					<ul>
						<li><a href="#handler-attr">attr</a></li>
						<li><a href="#handler-checked">checked</a></li>
						<li><a href="#handler-class-name">className</a></li>
						<li><a href="#handler-collection">collection</a></li>
						<li><a href="#handler-css">css</a></li>
						<li><a href="#handler-disabled">disabled</a></li>
						<li><a href="#handler-enabled">enabled</a></li>
						<li><a href="#handler-events">events</a></li>
						<li><a href="#handler-html">html</a></li>
						<li><a href="#handler-text">text</a></li>
						<li><a href="#handler-toggle">toggle</a></li>
						<li><a href="#handler-value">value</a></li>
					</ul>
			
					<b><a href="#binding-operators">View Binding Operators</a></b>
					<ul>
						<li><a href="#operator-all">all</a></li>
						<li><a href="#operator-any">any</a></li>
						<li><a href="#operator-none">none</a></li>
						<li><a href="#operator-not">not</a></li>
						<li><a href="#operator-format">format</a></li>
					</ul>
				</div>
			</div>
		</div>
		<div class="main">
			<div class="section">
				<h2 id="model">Epoxy.Model</h2>
			
				<p>The Epoxy Model object extends <tt>Backbone.Model</tt>, providing a new model abstract to be extended into your application.</p>

				<p>The Epoxy model introduces observable attributes on top of Backbone's native model attributes. Observable attributes are virtualized properties of the model: they may be <b>get</b> and <b>set</b> just like normal model attributes, and will trigger <tt>"change"</tt> events on the model when modified, however they do not exist within the model's <b>attributes</b> table, nor will they be saved with model data. Observable model attributes exist only in memory for the lifespan of a model instance. The goal of observable attributes is to provide an intermediary layer between a model's data and its display; allowing stateful view data (such as view selection states) to be managed within the model, yet not be retained by data stores.</p>

				<p>Additionally, Epoxy's observable attributes may be <i>computed</i>. Computed attributes operate as accessors and mutators, where a computed attribute will <b>get</b> an assembled value derived from other model attributes, and will <b>set</b> one more more mutated values derived from an input. Computed observables bind themselves to their dependency model attributes and will update themselves in response to any of their dependencies changing, then in turn trigger their own <tt>"change:attributeName"</tt> event on the model.</p>
			</div>
			<div class="section">
				<b class="header" id="model-extend">extend</b>
				<code>Backbone.Epoxy.Model.extend(properties, [classProperties])</code>
				<p>Extends the <tt>Epoxy.Model</tt> constructor for use in your own implementation.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-constructor">constructor</b>
				<code>new Backbone.Epoxy.Model([attributes], [options])</code>
				<p>Creates a new <tt>Epoxy.Model</tt> instance.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-add-observable">addObservable</b>
				<code>model.addObservable(name, value)</code>
				<p>Adds an observable attribute to the model. Observable attributes are virtualized properties of the model: they may be <b>get</b> and <b>set</b> just like normal model attributes, and will trigger <tt>"change"</tt> events on the model when modified, however they do not exist within the model's <b>attributes</b> table, nor will they be saved with model data. Observable model attributes exist only in memory for the lifespan of a model instance. The goal of observable attributes is to provide an intermediary layer between a model's data and its display; allowing stateful view data (such as view selection states) to be managed within the model, yet not be retained by data stores.</p>

				<p>Observable attributes may store any type of data, and will trigger normal <tt>"change:attributeName"</tt> events when set through the model's standard <b>set</b> method.</p>
				
				<p>Observable attributes storing object values (<tt>Object</tt> or <tt>Array</tt>) will trigger <tt>"change"</tt> events in response to changes in object composition, rather than object identity (this differs from the base Backbone Model, which will only trigger <tt>"change"</tt> events when a unique object instance replaces another within the model). Object comparison checks are performed using Underscore's <b>isEqual</b> method, which will compare the composition of objects and the contents of arrays. Performance should be considered when managing large objects.</p>
				
<pre><button class="run">Run</button><code>var model = new Backbone.Epoxy.Model();
model.addObservable("isSelected", false);
alert( model.get("isSelected") );</code>	
</pre>
				<p>Use the <b><a href="#model-observables">observables</a></b> hash to automatically construct observables on your model instances.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-add-computed">addComputed</b><br>
				<code>model.addComputed(name, params) or...</code><br>
				<code>model.addComputed(name, getter, [setter], [*deps])</code>
				<p>Adds a computed observable attribute to the model. Computed attributes operate as accessors and mutators, where a computed attribute will <b>get</b> an assembled value derived from other model attributes, and will <b>set</b> one more more mutated values derived from an input. Computed observables bind themselves to their dependency attributes and will update themselves in response to any of their dependencies changing, then in turn trigger their own <tt>"change:attributeName"</tt> event on the model.</p>

				<p id="model-computed-params">The <b>addComputed</b> method is called with an attribute name and a params object defining the following:</p>
				
				<ul>
					<li><b>get:</b> <i>Required function; invoked in context of the model</i>. This getter function assembles its value based on other model properties (attributes, observables, or other computeds), then returns the generated value. Note that a getter function should always reference other model values using the model's <b>get</b> method (for <a href="#model-computed-deps">automatic dependency mapping</a>).</li>
                    
					<li><b>[deps]:</b> <i>Optional array</i>. An array of attribute names that the getter function depends on. This manual property mapping is only required if your getter contains unreachable values that would be missed by automatic dependency mapping (discussed below).</li>
                    					
					<li><b>[set]:</b> <i>Optional function; invoked in context of the model</i>. A mutator function which receives a raw input value, and returns an object defining new key/value pairs to be merged into the model. Computed observables declared without a <b>set</b> function are read-only.</li>
				</ul>
				
				<p>Note that the <b>get</b> and <b>set</b> functions are invoked in the context of their parent model, so referencing <tt>this</tt> within their scopes refers to the model.</p>
				
<pre><button class="run">Run</button><code>var model = new Backbone.Epoxy.Model({price:100});
model.addComputed("formattedPrice", {
    deps: ["price"],
    get: function() {
        return "$"+ this.get("price");
    },
    set: function( value ) {
        return {price: parseInt(value.replace("$", ""))}
    }
});

console.log( model.get("formattedPrice") ); // "$100"
model.set("formattedPrice", "$150");
console.log( model.get("price") ); // 150</code>	
</pre>
				
				<p><b id="model-computed-deps">Automatic Dependency Mapping</b></p>
				<p>In the above example, <tt>["price"]</tt> is manually declared as a dependency of the computed getter (meaning the getter will need to update itself when <tt>"price"</tt> changes). While this manual declaration is a nice safety net, we could also exclude the <tt>"deps"</tt> param entirely in this case thanks to Epoxy's automatic dependency mapping.</p>
				
				<p>Automatic dependency mapping works using the <b>get</b> method wrapper of the <tt>Epoxy.Model</tt>. While generating a computed attribute's initial value, the <tt>Epoxy.Model</tt> registers all attribute names requested from <i>all</i> <tt>Epoxy.Model</tt> instances, and binds the computed attribute accordingly. Automatic mapping works great given the following:</p>
				
				<ul>
					<li>All model references (the parent model, or others) are instances of <tt>Epoxy.Model</tt>.</li>
					<li>All model attributes are accessed using their model's <b>get</b> method.</li>
					<li>All <b>get</b> calls are free of conditional logic (keep reading...)</li>
				</ul>
				
				<p>Regarding conditional <b>get</b> calls: this situation may create unreachable getters that cannot be automatically mapped. Consider the following BROKEN example:</p>
				
<pre>
<code>var model = new Backbone.Epoxy.Model({
    shortName: "Luke",
    fullName: "Luke Skywalker",
    active: false
});

// BROKEN:
model.addComputed("displayName", function() {
    return this.get("active") ? this.get("fullName") : this.get("shortName");
});</code>	
</pre>
				<p>See the error in the above example? The <tt>"fullName"</tt> and <tt>"shortName"</tt> attributes are accessed conditionally, therefore one will be unreachable while mapping dependencies. To fix this, we could either manually declare dependencies, or else <b>get</b> all dependencies as local variables prior to conditional logic, like so:</p>
				
<pre>
<code>// FIXED:
model.addComputed("displayName", function() {
    var fullName = this.get("fullName");
    var shortName = this.get("shortName");
    return this.get("active") ? fullName : shortName;
});</code>	
</pre>
				<p>Use the <b><a href="#model-computeds">computeds</a></b> hash to automatically construct computed observables on your model instances.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-clear-observables">clearObservables</b>
				<code>model.clearObservables()</code>
				<p>Removes all observable properties on the model and cleans up their bound events. Cleared observables will no longer exist on the model, so will no longer be accessible or trigger events. Be sure to call <b>clearObservables</b> when deprecating an Epoxy model without specifically calling its <b>destroy</b> method.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-computeds">computeds</b>
				<code>model.computeds</code>
				<p>A hash table declaring computed observable attributes to be automatically added to a model instance by the constructor. Uses <b><a href="#model-add-computed">addComputed</a></b> to create observable attributes. Computed observables may be declared with a <a href="#model-computed-params">computed params</a> object, or as a getter function (uses <a href="#model-computed-deps">automatic dependency mapping</a>).</p>	
<pre>
<code>var ComputedModel = Backbone.Epoxy.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    },
    computeds: {
        fullNameParams: {
            deps: ["firstName", "lastName"],
            get: function() {
                return this.get("firstName") +" "+ this.get("lastName");
            },
            set: function( value ) {
                var first = value.split(" ")[0];
                var last = value.split(" ")[1];
                return {firstName: first, lastName: last};
            }
        },
        fullNameGetter: function() {
            return this.get("firstName") +" "+ this.get("lastName");
        }
    }
});</code>
</pre>
			</div>
			
			<div class="section">
				<b class="header" id="model-destroy">destroy</b>
				<code>model.destroy([options])</code>
				<p>Override wrapper for the Backbone Model's native <b>destroy</b> method. This wrapper cleans up Epoxy model configuration, then defers to the Backbone Model's native <b>destroy</b> method. If you'd like to clean up a model without completely destroying it, use the <b>clearObservables</b> method.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-get">get</b>
				<code>model.get(attribute)</code>
				<p>Override wrapper for the Backbone Model's native <b>get</b> method. This override allows basic model attributes and Epoxy observable/computed attributes to be accessed through a common API.</p>
				<p>The Epoxy <b>get</b> method will first check for an observable attribute, then defers to the Backbone Model's native <b>get</b> method if no observable was found. Remember that an observable attribute overrides a native attribute with the same name, so be mindful of naming collisions.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-get-copy">getCopy</b>
				<code>model.getCopy(attribute)</code>
				<p>Gets a model attribute value (native, observable, or computed), and performs a shallow copy on any non-primitive values returned. This is useful for getting copies of <tt>Object</tt> and <tt>Array</tt> values that you plan to modify outside of the model, then resubmit with changes (remember that <tt>"change"</tt> events only trigger for non-primitive values when their identity changes). The <b><a href="#model-modify-array">modifyArray</a></b> and <b><a href="#model-modify-object">modifyObject</a></b> methods may also be used to perform object changes internally within the model.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-has-observable">hasObservable</b>
				<code>model.hasObservable(attribute)</code>
				<p>Returns <tt>true</tt> if the model has an observable or computed observable attribute with the specified name. Note that the Backbone Model's native <b>has</b> method is NOT modified by Epoxy, so will still only report on the presence of Backbone-native model attributes.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-modify-array">modifyArray</b>
				<code>model.modifyArray(attribute, arrayMethod, [*args])</code>
				<p>Performs an internal update on a stored <tt>Array</tt> model attribute (native or observable) using a standard JavaScript array modifier (<tt>pop</tt>, <tt>push</tt>, <tt>reverse</tt>, <tt>shift</tt>, <tt>slice</tt>, <tt>sort</tt>, <tt>splice</tt>, and <tt>unshift</tt>), then triggers a change event for the modified model attribute. Invoke with the model attribute name to modify, a string of the array method name to call, and any additional arguments to be passed into the array method. Returns any results from the array method. Calling <b>modifyArray</b> on a non-array attribute will take no action.</p>
				
<pre><button class="run">Run</button><code>var model = new Backbone.Epoxy.Model({wordList:[]});
model.modifyArray("wordList", "push", "coconut");
alert( model.get("wordList").length );</code>	
</pre>
			</div>

			<div class="section">
				<b class="header" id="model-modify-object">modifyObject</b>
				<code>model.modifyObject(attribute, objectProperty, value)</code>
				<p>Performs an internal update on a stored <tt>Object</tt> model attribute (native or observable), then triggers a change event for the modified model attribute. Invoke with the model attribute name to modify, a property name to set on the object, and a value to set as the object property. Setting <tt>undefined</tt> to a property will delete it from the object. Returns the modified object. Calling <b>modifyObject</b> will only take action on model attributes with an assessed type of <tt>"object"</tt>.</p>
				
<pre><button class="run">Run</button><code>var model = new Backbone.Epoxy.Model({ wordsDict:{} });
model.modifyObject("wordsDict", "coconut", true);
alert( model.get("wordsDict").hasOwnProperty("coconut") );</code>	
</pre>
			</div>
			
			<div class="section">
				<b class="header" id="model-observables">observables</b>
				<code>model.observables</code>
				<p>A hash table declaring observable attributes to be automatically added to a model instance by the constructor. Uses <b><a href="#model-add-observable">addObservable</a></b> to create observable attributes.</p>
<pre>
<code>var ComputedModel = Backbone.Epoxy.Model.extend({
    observables: {
        isSelected: false,
        todosList: new Backbone.Collection()
    }
});</code>
</pre>	
			</div>
			
			<div class="section">
				<b class="header" id="model-remove-observable">removeObservable</b>
				<code>model.removeObservable(attribute)</code>
				<p>Removes an observable attribute by name, and cleans up all bound listeners. A removed observable property will no longer exist within the model, so may no longer be accessed or trigger events.</p>
			</div>
			
			<div class="section">
				<b class="header" id="model-set">set</b>
				<code>model.set(attributes, [options])</code>
				<p>Override wrapper for the Backbone Model's native <b>set</b> method. This override allows basic model attributes and Epoxy observable/computed attributes to be accessed through a common API.</p>
				<p>The Epoxy <b>set</b> method will first check for an observable attribute, then defers to the Backbone Model's native <b>set</b> method if no observable was found. Remember that an observable attribute overrides a native attribute with the same name, so be mindful of naming collisions.</p>
			</div>
			
			<div class="section">
				<h2 id="view">Epoxy.View</h2>

				<p>The Epoxy View object extends <tt>Backbone.View</tt>, providing a new view abstract to be extended into your application.</p>

				<p>The Epoxy View provides elegant and extensible hooks for binding a model's attributes directly to DOM elements. When model attributes change, they will automatically trigger refresh of all bound view elements; seamlessly updating your UI without requiring a complete render pass.</p>

				<p>Note that an Epoxy View may bind directly to a native Backbone Model, or to an <tt>Epoxy.Model</tt> with specialized observable attributes. Because both model types operate through a common API, the Epoxy View does not depend on its <tt>Epoxy.Model</tt> counterpart to support model bindings (unless otherwise noted). Therefore, you're free to exclude <tt>Epoxy.Model</tt> resources from your project if you just want view binding features.</p>
			</div>
			
			<div class="section">
				<b class="header" id="view-extend">extend</b>
				<code>Backbone.Epoxy.View.extend(properties, [classProperties])</code>
				<p>Extends the <tt>Epoxy.View</tt> constructor for use in your own implementation.</p>
			</div>
			
			<div class="section">
				<b class="header" id="view-constructor">constructor</b>
				<code>new Backbone.Epoxy.View([options])</code>
				<p>Creates a new <tt>Epoxy.View</tt> instance.</p>
			</div>
			
			<div class="section">
				<b class="header" id="view-context">binding context</b>
				<code>{$model:model, $collection:collection, [*attributes]}</code>
				<p>To establish bindings, an Epoxy view generates a <i>binding context</i> with routes pointing to all available <i>data sources</i> and their attributes. Data sources are instances of <tt>Backbone.Model</tt> and/or <tt>Backbone.Collection</tt> that provide themselves and their attributes to the view for binding. By default, an Epoxy view looks for two potential data sources: the view's <b>model</b> property, and its <b>collection</b> property. References to these data sources are automatically configured in the binding context as <tt>$model</tt> and <tt>$collection</tt>. Additionally, aliases to all <tt>$model</tt> attributes are created.</p>
			</div>
			
			<div class="section">
				<b class="header" id="view-apply-bindings">applyBindings</b>
				<code>view.applyBindings()</code>
				<p>Removes any existing view bindings, then applies all bindings defined within the view's <b>bindings</b> object. All bindings are established using the view's <b>$el</b> as the display target, and the view's <b>model</b> as the data target (<b>model</b> must reference a valid <tt>Backbone.Model</tt> instance). A view with invalid display or data targets will apply no bindings. If the <b>bindings</b> object is a string, that string will be used as an attribute selector query for extracting bindings from the view's <b>$el</b> container.</p>

				<p>The <b>applyBindings</b> method is automatically called by the view constructor after the view's <b>initialize</b> method runs. This allows the <b>initialize</b> step to make adjustments within the view prior to bindings being applied. You generally shouldn't need to call <b>applyBindings</b> manually.</p>

				<p>Also note that view bindings are baked at the time they are applied. All relationships between the model and the view are established during this binding step, and will NOT update automatically to new configurations. Dynamically adding and removing model attributes and/or view bindings will require the view to be completely unbound, and then rebound.</p>
			</div>
			
			<div class="section">
				<b class="header" id="view-binding-handlers">bindingHandlers</b>
				<code>view.bindingHandlers</code>
				<p>A hash table defining a view's custom binding handlers. Binding handlers are used to interchange model data with elements in the view. While Epoxy includes a <a href="#binding-handlers">core set</a> of basic binding handlers for managing an element's content and formatting, developers are encouraged to extend their views with customized binding handlers.</p>
					
				<p>To declare binding handlers, define a new property on the <b>bindingHandlers</b> hash with a params object defining <b>set</b> and <b>get</b> function properties:</p>

<pre>
<code>var BindingView = Backbone.Epoxy.View.extend({
    bindingHandlers: {
        printList: {
            set: function( $element, value ) {
                $element.text( value.join(",") );
            },
            get: function( $element, value ) {
                return $element.text().split(",");
            }
        }
    }
});</code>
</pre>				
				<ul>
					<li><b>set:</b> <i>Required function, invoked in context of the view</i>. This function is used to WRITE data from the model into the view. The <b>set</b> function receives two arguments: a jQuery representation of the bound element, and the model attribute value to be written into the view. The <b>set</b> function returns nothing.</li>
					<li><b>[get]:</b> <i>Optional function, invoked in context of the view</i>. This function is used to READ data from the view to be sent to the model. The <b>get</b> function receives two arguments: a jQuery representation of the bound element, and the current model attribute value to be changed (useful when modifying objects). The <b>get</b> function should return a value to replace the current bound model attribute. When modifying <tt>Object</tt> and <tt>Array</tt> values, be sure to make changes to a <i>copy</i> of the current value, then submit that back to the model.</li>
				</ul>
				
				<p>Note that the <b>get</b> and <b>set</b> functions are invoked in the context of their parent view, so referencing <tt>this</tt> within their scopes refers to the view.</p>
				
				<p>While declaring a display-only binding handler (one-way binding), you may declare its setter function directly on the <b>bindingHandlers</b> hash:</p>

<pre>
<code>var BindingView = Backbone.Epoxy.View.extend({
    bindingHandlers: {
        printList: function( $element, value ) {
            $element.text( value.join(",") );
        }
    }
});</code>
</pre>
			</div>
			
			<div class="section">
				<b class="header" id="view-bindings">bindings</b>
				<code>view.bindings</code>
				<p>A hash declaring the view's element-to-attribute binding scheme, or a string defining an element attribute to query from the view's DOM. All bindings are established using the view's <b>$el</b> reference as the display target, and the view's <b>model</b> reference as the data target. A view missing its <b>$el</b> and/or <b>model</b> properties will apply no bindings.</p>
				
				<p>The bindings hash syntax keeps all binding declarations within the view. The <b>bindings</b> object declares a set of key/value pairs, where the key defines an element query, and the value defines the element's model bindings:</p>
<pre>
<code>var BindingModel = Backbone.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    }
});
	
var BindingView = Backbone.Epoxy.View.extend({
    model: new BindingModel(),
    bindings: {
        "input.first-name": "value:firstName,events:['keyup']",
        "input.last-name": "value:lastName,events:['keyup']"
    }
});</code>
</pre>
				<p>Alternatively, you may choose to follow the popular convention of declaring bindings directly within the DOM using element attributes, at which time the <b>bindings</b> property should define the attribute name to query for. Epoxy specifies <tt>"data-bind"</tt> by default. All philosophical opinions aside, this technique works just as well as view-based declarations. Getting into philosophy, this method creates a bizarre (albeit handy) relationship between JavaScript mechanics and raw display. Ultimately, the choice is yours as to which method works best for your purposes.</p>

<pre>
<code>var BindingModel = Backbone.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    }
});

var BindingView = Backbone.Epoxy.View.extend({
    el: "#binding-view"
    model: new BindingModel(),
    bindings: "data-bind"
});

&lt;div id="binding-view"&gt;
    &lt;p&gt;First: &lt;input type="text" data-bind="value:firstName,events:['keyup']"&gt;&lt;/p&gt;
    &lt;p&gt;Last: &lt;input type="text" data-bind="value:lastName,events:['keyup']"&gt;&lt;/p&gt;
&lt;/div&gt;</code>
</pre>
			</div>
			
			<div class="section">
				<b class="header" id="view-remove">remove</b>
				<code>view.remove()</code>
				<p>Override wrapper for the Backbone Views's native <b>remove</b> method. This override calls <b>removeBindings</b>, then defers to the Backbone View's native <b>remove</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="view-remove-bindings">removeBindings</b>
				<code>view.removeBindings()</code>
				<p>Removes and cleans up all bindings applied to the view. All binding hooks will be nullified, leaving the view's DOM elements formatted in their final bound state. The <b>removeBindings</b> method is automatically called with the <b>remove</b> method. Be mindful that you should manually call <b>removeBindings</b> when deprecating an Epoxy view without specifically calling its <b>remove</b> method.</p>
			</div>
			<div class="section">
				<h2 id="binding-handlers">View Binding Handlers</h2>
				<p>Binding handlers are used to interchange model data with elements in the view. The Epoxy <tt>View</tt> includes default binding handlers for common tasks such as managing a bound element's content, class, and style. However, don't feel limited to just Epoxy's out-of-the-box binding handlers. You may easily <a href="#view-binding-handlers">define your own binding handlers</a> within a view.</p>
				
				<p>One or more binding handlers may be applied to an element as a comma-separated properties list (here shown using DOM attribute bindings):</p>

<pre>
<code>&lt;a data-bind="text:linkText,attr:{href:linkUrl,title:linkText}"&gt;&lt;/a&gt;</code>
</pre>
				<p>In the above example, <tt>"text:"</tt> and <tt>"attr:"</tt> are binding handlers, while <tt>"linkText"</tt> and <tt>"linkUrl"</tt> are the bound model attributes assigned to them. In the case of the <tt>"attr"</tt> handler, its value is a hash of attribute names, each with an associated model value.</p>
				
				<p>Be aware that binding declarations are parsed as JavaScript <tt>Object</tt> bodies, therefore a binding declaration <i>must</i> conform to proper JavaScript syntax. To give due credit, Epoxy's binding system is modeled after the clever technique used in <a href="http://knockoutjs.com/">Knockout.js</a>. However, Epoxy deliberately limits some of Knockout's free-form binding allowances, such as inline concatenation (which becomes overly technical within the presentation layer, IMHO). If you're coming from Knockout, don't expect to write as much inline binding JavaScript.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-attr">attr</b>
				<span class="alias">read-only</span>
				<code>data-bind="attr:{name:modelAttribute,'data-name':modelAttribute}"</code>
				<p>Binds model attribute values to a list of element attributes. Attribute bindings are defined as a hash of key/value pairs, where each key defines an element attribute and the model reference defines the attribute value. Attribute keys may be defined as strings.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-checked">checked</b>
				<span class="alias">read-write</span>
				<code>data-bind="checked:modelAttribute"</code>
				<p>Binds <tt>checkbox</tt> and <tt>radio</tt> elements to the model. The binding behavior differs slightly for various element/value combinations:</p>

				<ul>
					<li><b>Radios:</b> a bound <tt>radio</tt> element will become checked when the element's <tt>value</tt> matches the bound model attribute. Checking a radio will set its <tt>value</tt> to the bound model attribute.</li>

					<li><b>Checkbox arrays:</b> when a <tt>checkbox</tt> element is bound to an <tt>Array</tt> model attribute, the element will be checked while its <tt>value</tt> exists within the value array, and unchecked while its <tt>value</tt> is absent from the array. Likewise, toggling the element's <tt>checked</tt> property will add and remove its value from the bound array. Keep in mind that arrays modified within a native <tt>Backbone.Model</tt> will NOT trigger a <tt>"change"</tt> event unless the array <i>instance</i> is changed. Using an <tt>Epoxy.Model</tt> observable will help here by managing object copies, and by performing array comparisons by content.</li>

				 	<li><b>Checkbox toggles:</b> when a <tt>checkbox</tt> element is bound to a primitive model attribute (types <tt>String</tt>, <tt>Boolean</tt>, or <tt>Number</tt>), the element will be checked based on a loosely-typed assessment of the model attribute's truthiness. When the element's <tt>"checked"</tt> status is toggled, it will submit a <tt>Boolean</tt> value back to the model attribute.</li>
				</ul>
			</div>
			
			<div class="section">
				<b class="header" id="handler-class-name">classes</b>
				<span class="alias">read-only</span>
				<code>data-bind="classes:{active:modelAttr,'is-active':modelAttr}"</code>
				<p>Toggles a list of element class names based on the truthiness of their bound model attributes. Class bindings are defined as a hash of key/value pairs, where each key defines a class name and is value references a model attribute that will be loosely-type checked for truthiness; truthy attributes will enable their class, while falsey attributes will disable their class. Class name keys may be defined as strings.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-collection">collection</b>
				<span class="alias">read-only</span>
				<code>data-bind="collection:observableName"</code>
				<p>Binds the display of a <tt>Backbone.Collection</tt>. The bound collection defines a <tt>View</tt> for its models, which allows the collection handler to take care of adding, removing, and resorting views to keep the display in sync with the collection. One key feature of the <b>collection</b> binding's view management is that it does NOT perform a full re-render of the collection contents for each change. Instead, the <b>collection</b> binding attempts to retain as much existing view as possible, only adding and removing as needed, and performing optimized element sorts when required. You may choose to use <tt>Epoxy.View</tt> elements for the display of individual collection items, allowing each collection item view to also bind to its model.</p>

				<p>The collection binding requires the following setup:</p>

				<ul>
					<li>The binding view's model must be an instance of <tt>Epoxy.Model</tt>, with the target collection stored as an observable property. This observable wrapper is required for aggregating collection events that will trigger view updates.</li>

					<li>The bound collection must have a property called <b>view</b> which defines a Backbone View constructor for displaying collection items (this mirrors the pattern of a collection's <b>model</b> property defining its Model constructor).</li>
				</ul>

				<p>For a working demonstration of setting up a <b>collection</b> binding, see the Epoxy <a href="#">ToDo demo</a>.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-css">css</b>
				<span class="alias">read-only</span>
				<code>data-bind="css:{color:modelAttribute,'font-size':modelAttribute}"</code>
				<p>Binds a list of CSS styles to model attributes. CSS style bindings are defined as a hash of key/value pairs, where each key defines a CSS style name and the model attribute defines the style's literal value. CSS keys may be defined as strings.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-disabled">disabled</b>
				<span class="alias">read-only</span>
				<code>data-bind="disabled:modelAttribute"</code>
				<p>Toggles a form element's <tt>"disabled"</tt> property based on a loosely-typed assessment of the bound model attribute's truthiness. A truthy value disables the element (inversion of the <b>enabled</b> handler).</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-enabled">enabled</b>
				<span class="alias">read-only</span>
				<code>data-bind="enabled:modelAttribute"</code>
				<p>Toggles a form element's <tt>"disabled"</tt> status based on a loosely-typed assessment of the bound model attribute's truthiness. A truthy value enables the element (inversion of the <b>disabled</b> handler).</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-events">events</b>
				<span class="alias">read-only</span>
				<code>data-bind="events:['keydown','focus']"</code>
				<p>The <b>events</b> handler is a special binding used to parameterize what DOM events will trigger changes for read-write element bindings. By default, all read-write bindings will subscribe to their bound element's <tt>"change"</tt> event to trigger model updates. You may bind additional DOM event triggers for the element by listing them in the <b>events</b> array.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-html">html</b>
				<span class="alias">read-only</span>
				<code>data-bind="html:modelAttribute"</code>
				<p>Sets the element's HTML content to the bound model attribute value. Uses the jQuery <b>html</b> method.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-text">text</b>
				<span class="alias">read-only</span>
				<code>data-bind="text:modelAttribute"</code>
				<p>Sets the element's text content to the bound model attribute value. Uses the jQuery <b>text</b> method.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-toggle">toggle</b>
				<span class="alias">read-only</span>
				<code>data-bind="toggle:modelAttribute"</code>
				<p>Toggles the element's display based on a loosely-typed assessment of the bound model attribute's truthiness. Uses the jQuery <b>toggle( [boolean] )</b> method.</p>
			</div>
			
			<div class="section">
				<b class="header" id="handler-value">value</b>
				<span class="alias">read-write</span>
				<code>data-bind="value:modelAttribute"</code>
				<p>Binds an input element's (<tt>input</tt>, <tt>select</tt>, <tt>textarea</tt>) value to an underlying model attribute. The element will set its <tt>value</tt> to the bound model attribute upon change event triggers (see the <b><a href="#handler-events">events</a></b> handler), and update its <tt>value</tt> when the underlying model attribute changes.</p>
			</div>
			
			<div class="section">
				<h2 id="binding-operators">View Binding Operators</h2>
				<p>Binding operators provide a layer of flexibility for formatting model attribute values directly within a binding declaration, while still conforming to a preset binding API. Binding operators work by wrapping one or more model attribute accessors, allowing their values to be formatted specifically for the context of the binding.</p>
			</div>
			
			<div class="section">
				<b class="header" id="operator-all">all</b>
				<code>data-bind="toggle:all(modelAttribute,modelAttribute)"</code>
				<p>Assesses one or more model attributes as <tt>true</tt> if <i>all</i> attributes are truthy.</p>
			</div>
			
			<div class="section">
				<b class="header" id="operator-any">any</b>
				<code>data-bind="toggle:any(modelAttribute,modelAttribute)"</code>
				<p>Assesses one or more model attributes as <tt>true</tt> if <i>any</i> of the attributes are truthy.</p>
			</div>
			
			<div class="section">
				<b class="header" id="operator-none">none</b>
				<code>data-bind="toggle:none(modelAttribute,modelAttribute)"</code>
				<p>Assesses one or more model attributes as <tt>true</tt> if <i>none</i> of the attributes are truthy.</p>
			</div>
			
			<div class="section">
				<b class="header" id="operator-not">not</b>
				<code>data-bind="toggle:not(modelAttribute)"</code>
				<p>Inverts the loosely-typed boolean value of a model attribute.</p>
			</div>
			
			<div class="section">
				<b class="header" id="operator-format">format</b>
				<code>data-bind="text:format('$1 of $2',modelAttribute,modelAttribute)"</code>
				<p>Formats a string with a series of model attribute replacements. Operates the same as string replacement for <tt>RegExp</tt> capture groups, where field insertions are denoted as <tt>"$1,&nbsp;$2,&nbsp;...&nbsp;$n"</tt>. Escape intentional "$n" patterns within the template string as "\$n". Note that the first value insertion index is 1, not 0.</p>
			</div>
			
			
			<div class="footer">
				<p>Epoxy.js for Backbone is available in a <a href="https://github.com/gmac/backbone.epoxy">GitHub Repo</a>.<br>
					&copy; 2013 Greg MacWilliam (<a href="https://twitter.com/gmacwilliam">@gmacwilliam</a>), a project of <a href="http://www.threespot.com">Threespot</a>.</p>
			</div>
		</div>
	</div>
	<script src="../lib/jquery.js"></script>
	<script src="../lib/underscore.js"></script>
	<script src="../lib/backbone.js"></script>
	<script src="../backbone.epoxy.min.js"></script>
	<script src="js/global.js"></script>
</body>
</html>