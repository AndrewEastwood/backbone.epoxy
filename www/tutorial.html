<!DOCTYPE html>
<html lang="en">
<head>
	<title></title>
	<link href="css/reset.css" rel="stylesheet">
	<link href="css/screen.css" rel="stylesheet">
</head>
<body>
	<div id="page">
		<div class="banner" role="banner">
			<h1>Epoxy.js: Elegant Data Binding for Backbone</h1>
		</div>
		<div class="navigation" role="navigation">
			<ul class="nav-main">
				<li><a href="index.html">About</a></li>
				<li><a href="tutorial.html">Tutorial</a></li>
				<li><a href="doc.html">Documentation</a></li>
			</ul>
			<div class="nav-toc">
				<div class="nav-toc-content">
					<ol>
						<li><a href="#installation">Installation</a></li>
						<li><a href="#simple-bindings">Simple View Bindings</a></li>
						<li><a href="#computed-bindings">Computed Observables</a></li>
						<li><a href="#computed-dependencies">Computed Dependencies</a></li>
						<li><a href="#computed-get-set">Computed Getters and Setters</a></li>
						<li><a href="#binding-operators">Formatting View Bindings</a></li>
						<li><a href="#binding-handlers">Custom Binding Handlers</a></li>
						<li><a href="#epoxy-todos">Epoxy ToDos</a></li>
					</ol>
				</div>
			</div>
		</div>
		<div class="main" role="main">
			<h1 id="installation">Installation</h1>

			<p>Epoxy requires <a href="http://jquery.com/">jQuery</a> 1.7.0+, <a href="http://underscorejs.org/">Underscore</a> 1.4.3+, and <a href="http://backbonejs.org/">Backbone</a> 0.9.9+. To quickly install Epoxy, download the full Epoxy bundle (7k, 3k gzipped) and include its script tag in your document after all of its dependencies:</p>

<pre><code>&lt;script src="jquery-min.js"&gt;&lt;/script&gt;
&lt;script src="underscore-min.js"&gt;&lt;/script&gt;
&lt;script src="backbone-min.js"&gt;&lt;/script&gt;
&lt;script src="backbone.epoxy.min.js"&gt;&lt;/script&gt;</code></pre>

			<p>Note that Epoxy's <tt>Model</tt> and <tt>View</tt> components operate independently of each other, so you may choose to only include a single Epoxy component script. Each individual component script is roughly 3k, 1.5k gzipped.</p>

			<h1 id="simple-bindings">Simple View Binding</h1>

			<p>Let's start by setting up a simple binding between a few DOM elements who's content we want to update when their underlying model data changes:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>

<pre class="js"><code>var bindModel = new Backbone.Model({
    firstName: "Luke",
    lastName: "Skywalker"
});

var BindingView = Backbone.Epoxy.View.extend({
    el: "#bind-luke",
    bindings: {
        "input.first-name": "value:firstName,events:['keyup']",
        "input.last-name": "value:lastName,events:['keyup']",
        "span.first-name": "text:firstName",
        "span.last-name": "text:lastName"
    }
});

var view = new BindingView({model: bindModel});</code></pre>

<pre class="html"><code>&lt;div id="bind-luke" class="demo"&gt;
	&lt;label>First:&lt;/label&gt;
	&lt;input type="text" class="first-name"&gt;
	
	&lt;label>Last:&lt;/label&gt;
	&lt;input type="text" class="last-name"&gt;
	
	&lt;b>Full Name:&lt;/b&gt;
	&lt;span class="first-name"&gt;&lt;/span&gt;
	&lt;span class="last-name"&gt;&lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>

			<p>In this example, we create a new instance of an Epoxy view, provide it a simple Backbone model, then use the <b>bindings</b> hash to declare bonds between view selectors and model attributes. Note that each model field is prefixed by a binding handler name; in this case, "value" establishes a two-way binding between a text input and its model field, "events" specifies element events to respond to, and "text" creates a one-way binding that displays model data within the view.</p>

			<p>Another popular approach to data binding is to declare bindings as attributes on the DOM elements they target. Epoxy also supports this syntax:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>
		
<pre class="js"><code>var bindModel = new Backbone.Model({
    firstName: "Han",
    lastName: "Solo"
});

var BindingView = Backbone.Epoxy.View.extend({
    el: "#bind-han",
    bindings: "data-bind"
});

var view = new BindingView({model: bindModel});</code></pre>

<pre class="html"><code>&lt;div id="bind-han" class="demo"&gt;
    &lt;label>First:&lt;/label&gt;
    &lt;input type="text" data-bind="value:firstName,events:['keyup']"&gt;
	
    &lt;label>Last:&lt;/label&gt;
    &lt;input type="text" data-bind="value:lastName,events:['keyup']"&gt;
	
    &lt;b>Full Name:&lt;/b&gt;
    &lt;span data-bind="text:firstName"&gt;&lt;/span&gt;
    &lt;span data-bind="text:lastName"&gt;&lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>

			<p>Here, the exact same binding scheme from above has been applied directly to the DOM as element attributes, and the view's <b>bindings</b> property simply defines the attribute name to search for bindings with (note: <tt>"data-bind"</tt> is the Epoxy default attribute name, so you don't need to specifically need to declare a binding attribute within your view unless you want to use a different attribute name).</p>

			<p>The above examples are functionally identical, and purely subjective as to your preferred approach.</p>

			<h1 id="computed-bindings">Computed Observables</h1>

			<p>Now let's add an <tt>Epoxy.Model</tt> into the mix. With Epoxy models, we can encapsulate a few tricks within the model architecture. Let's add in an Epoxy computed property, which will generate a computed value based on other model properties:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>

<pre class="js"><code>var BindingModel = Backbone.Epoxy.Model.extend({
    defaults: {
        firstName: "Obi-Wan",
        lastName: "Kenobi"
    },
    computeds: {
        fullName: function() {
            return this.get("firstName") +" "+ this.get("lastName");
        }
    }
});

var view = new Backbone.Epoxy.View({
    el: "#bind-computed",
    model: new BindingModel()
});</code></pre>

<pre class="html"><code>&lt;div id="bind-computed"&gt;
    &lt;label&gt;First:&lt;/label&gt;
    &lt;input type="text" data-bind="value:firstName,events:['keyup']"&gt;

    &lt;label&gt;Last:&lt;/label&gt;
    &lt;input type="text" data-bind="value:lastName,events:['keyup']"&gt;

    &lt;b&gt;Full Name:&lt;/b&gt;
    &lt;span data-bind="text:fullName">&lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>

			<p>In this example, our Epoxy model sets up a computed property for formatting a <tt>fullName</tt> value from individual model components. Our computed function is added as an observable property of the model. Observables are a concept introduced by Epoxy: an observable attribute may be <b>get</b> and <b>set</b> from the model just like a native Backbone model attribute, except that observable attributes exist independently from regular model data, and are not saved/synced with model data to a REST service. This anonymous quality of observable attributes makes them ideal of managing view-specific data, such as view selection status. Observables give a place for your view data to be managed, without polluting your underlying model data.</p>

			<p>Also, because Epoxy observable attributes are <b>get</b> and <b>set</b> through the standard Backbone Model API, this allows them to hook seamlessly into Epoxy view's data bindings. In the above example, you'll see that we've bound the computed property <tt>fullName</tt> into the view just like a normal model property.</p>

			<p>Now, if <tt>firstName</tt> or <tt>lastName</tt> attributes update within the model, what happens to <tt>fullName</tt>? Epoxy is smart enough to map computed property dependencies, and update computed properties when their dependencies update, and in turn propagate their revised values out to the display. We'll discuss dependency management of computed model properties in the next section.</p>

			<h1 id="computed-dependencies">Managing Computed Dependencies</h1>

			<p>As we saw in the previous example, Epoxy is smart enough to automatically map computed dependencies. While this may seem like black magic, all that's really going on is that Epoxy has wrapped the Backbone model's native <b>get</b> method, and is using it to keep track of requested attribute names. As long as you use an Epoxy model's <b>get</b> method for all attribute access (no digging directly into a model's <b>attributes</b> table), then one or more <tt>Epoxy.Model</tt> instances will automatically map references between one another.</p>

			<p>However, there's one big "gotcha" here... consider the following BROKEN example:</p>

<pre><code>// BROKEN:
var BrokenModel = Backbone.Epoxy.Model.extend({
    defaults: {
        userName: "tatooine_luke",
        fullName: "Luke Skywalker",
        isOnline: true
    },
    computeds: {
        displayName: function() {
            return this.get("isOnline") ? this.get("fullName") : this.get("userName");
        }
    }
});</code></pre>

			<p>See the problem above? Because <tt>displayName</tt> uses conditional logic, one of the two conditional <b>get</b> calls will be unreachable (and therefore missed) while automatically mapping dependencies. This makes for a busted model. To fix this, you may take two approaches...</p>
			
			<p>The first solution is to move all <b>get</b> calls outside of the conditional statement, and then let automatic mapping safely take its course. The following will work:</p>

<pre><code>// FIXED by pre-collecting references:
var FixedModel = Backbone.Epoxy.Model.extend({
    defaults: {
        userName: "tatooine_luke",
        fullName: "Luke Skywalker",
        isOnline: true
    },
    computeds: {
        displayName: function() {
            var fullName = this.get("fullName");
            var userName = this.get("userName");
            return this.get("isOnline") ? fullName : userName;
        }
    }
});</code></pre>

			<p>In the above solution, we've elevated all <b>get</b> calls to fall outside of the conditional block where they'll all be reached. This is always a good practice to follow when using automatic mapping.</p>

			<p>Alternatively, you may manually declare a computed property's dependencies, like so:</p>

<pre><code>// FIXED by manual declarations:
var FixedModel = Backbone.Epoxy.Model.extend({
    defaults: {
        userName: "tatooine_luke",
        fullName: "Luke Skywalker",
        isOnline: true
    },
    computeds: {
        displayName: {
            deps: ["isOnline", "fullName", "userName"], 
            get: function() {
                return this.get("isOnline") ? this.get("fullName") : this.get("userName");
            }
        }
    }
});
</code></pre>

			<p>In the above solution, we've defined the computed attribute using a params object with a <tt>deps</tt> array. This array declares property names that the computed getter depends on. Manually declaring dependencies alleviates the margin for automation errors, but introduces a margin for human errors. It's your call as to which direction seems safer.</p>

			<h1 id="computed-get-set">Computed Getters and Setters</h1>

			<p>So far we've only looked at computed attributes that use <b>get</b> functions to access their values. Now let's look at computed <b>set</b> capabilities, which will mutate values before setting them to the model:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>

<pre class="js"><code>var PriceModel = Backbone.Epoxy.Model.extend({
    defaults: {
        productName: "Light Saber",
        price: 5000
    },
    computeds: {
        displayPrice: {
            get: function() {
                return "$"+this.get("price");
            },
            set: function( value ) {
                return {price: parseInt(value.replace("$", "")||0, 10)};
            }
        }
    }
});

var view = new Backbone.Epoxy.View({
    el: "#bind-readwrite",
    model: new PriceModel()
});</code></pre>

<pre class="html"><code>&lt;div id="bind-readwrite"&gt;
    &lt;label&gt;Price:&lt;/label&gt;
    &lt;input type="text" data-bind="value:displayPrice"&gt;

    &lt;b&gt;Display Price:&lt;/b&gt;
    &lt;span data-bind="text:displayPrice">&lt;/span&gt;

    &lt;b&gt;Model Price:&lt;/b&gt;
    &lt;span data-bind="text:price">&lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>

			<p>Here, we've defined our computed property using a params object with both a <b>get</b> and <b>set</b> function. The <b>get</b> function will access our assembled model attribute, and <b>set</b> will mutate a raw value into formatted model data. In the above <tt>displayPrice</tt> example, we're formatting a currency string using the <b>get</b> method, and then reformatting input as a valid number within the <b>set</b> method before storing it in the model.</p>

			<p>Note that the setter function returns an <i>attributes hash</i> rather than calling <b>set</b> on its model directly. Attribute objects returned by a computed setter will be merged into the model's running <b>set</b> operation. This allows a computed setter to define multiple attribute modifications, all of which are performed synchronously with any other queued model changes.</p>

			<h1 id="binding-operators">Formatting View Bindings</h1>

			<p>Now let's turn our attention back to bindings within the Epoxy view. Epoxy tries to balance between powerful capabilities and binding cleanliness. While Epoxy uses a similar binding technique to <a href="http://knockoutjs.com/">Knockout.js</a>, it intentionally discourages some of Knockout's inline-javascript allowances.</p>

			<p>Instead, Epoxy provides a few binding wrapper operations, which may be used to modify and/or format binding values:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>

<pre class="js"><code></code></pre>

<pre class="html"><code>&lt;div id="bind-readwrite"&gt;
    &lt;label&gt;Price:&lt;/label&gt;
    &lt;input type="text" data-bind="value:displayPrice"&gt;

    &lt;b&gt;Display Price:&lt;/b&gt;
    &lt;span data-bind="text:displayPrice">&lt;/span&gt;

    &lt;b&gt;Model Price:&lt;/b&gt;
    &lt;span data-bind="text:price">&lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>

			<p>In the above example, wrapper operations are used to format a few model values for their specific implementations. The not() operator is used to negate selection status while toggling visibility, and the format() operator is used to format multiple model values into a display string neatly within the binding. See a full list of binding operators.</p>

			<h1 id="binding-handlers">Custom Binding Handlers</h1>

			<p>Epoxy provides a collection of default binding handlers to cover many basic view operations. For everything else, developers are encouraged to write their own binding handlers for custom scenarios. Custom bindings handlers are easy to define:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>

<pre class="js"><code>var model = new Backbone.Model({shipsList: []});

var BindingView = Backbone.Epoxy.View.extend({
    el: "#bind-custom",
    bindingHandlers: {
        listing: function( $element, value ) {
            $element.text( value.join(", ") );
        }
    }
});

var view = new BindingView({model: model});</code></pre>

<pre class="html"><code>&lt;div id="bind-custom"&gt;
    &lt;label&gt;Millennium Falcon:&lt;/label&gt;
    &lt;input type="checkbox" value="Millennium Falcon" data-bind="checked:shipsList"&gt;

    &lt;label&gt;Death Star:&lt;/label&gt;
    &lt;input type="checkbox" value="Death Star" data-bind="checked:shipsList"&gt;

    &lt;b&gt;Shopping Cart:&lt;/b&gt;
    &lt;span data-bind="listing:shipsList">&lt;/span&gt;
&lt;/div&gt;</code></pre>
</div>

			<p>In the above example, we've set up a custom binding handler called <tt>listing</tt> to neatly print out an array of values. That custom handler may then be declared as normal within the view's bindings, as demonstrated with the <tt>"listing:shipsList"</tt> binding.</p>
			<p>A binding handler is just a function that accepts two arguments: the first is a jQuery object wrapping the bound element, and the second is the model value being provided to the binding. Within a custom binding handler, we simply specify a process by which the value is formatted and then applied to the element. Note, the above example demonstrates a simple <i>read-only</i> binding. See the complete <a href="#view-binding-handlers">binding handlers documentation</a> for information on setting up <i>read-write</i> handlers.</p>

			<h1>Epoxy ToDos</h1>

			<p>Per the requirement of JavaScript MV* frameworks, let's build a small ToDos app using Epoxy view bindings paired with native Backbone models:</p>

<div class="scenario">
<ul class="tabs">
	<li data-tab="js">JavaScript</li>
	<li data-tab="html">HTML</li>
</ul>

<pre class="js"><code>// Model for each ToDo item:
var TodoItemModel = Backbone.Model.extend({
    defaults: {
        todo: "",
        complete: false
    }
});

// Epoxy View for each ToDo item:
var TodoItemView = Backbone.Epoxy.View.extend({
    el:"&lt;li&gt;&lt;input type='checkbox'&gt; &lt;input type='text' class='todo'&gt;&lt;/li&gt;",
    bindings: {
        "input[type='text']": "value:todo,readonly:complete,save:$model",
        "input[type='checkbox']": "checked:complete,save:$model"
    },
    bindingHandlers: {
        readonly: function( $element, value ) {
            $element.prop( "readonly", !!value );
        },
        save: function( $element, $model ) {
            $model.save();
        }
    }
});

// Collection for ToDo items:
var TodosCollection = Backbone.Collection.extend({
    model: TodoItemModel,
    view: TodoItemView,
    localStorage: new Backbone.LocalStorage("todos")
});

// Epoxy View for main ToDos app:
var TodoAppView = Backbone.Epoxy.View.extend({
    el: "#epoxy-todos",
    collection: new TodosCollection(),
    initialize: function() {
        this.collection.fetch();
    },
    bindings: {
        ".todos": "collection:$collection"
    },
    events: {
        "click .add": "onAdd",
        "click .cleanup": "onCleanup",
        "keydown .todo-add": "onEnter"
    },
    onEnter: function( evt ) {
        if ( evt.which == 13 ) this.onAdd();
    },
    onAdd: function() {
        var input = this.$(".todo-add");
		
        if ( input.val() ) {
            this.collection.create({todo: input.val()});
            input.val("");
        }
    },
    onCleanup: function() {
        _.invoke(this.collection.where({complete:true}), 'destroy');
    }
});

var app = new TodoAppView();</code></pre>

<pre class="html"><code>&lt;div id="epoxy-todos"&gt;
    &lt;b&gt;What do you need to do?&lt;/b&gt;
    &lt;p&gt;
        &lt;input type="text" class="todo-add"&gt;
        &lt;button class="add"&gt;Add&lt;/button&gt;
    &lt;/p&gt;
    &lt;ul class="todos"&gt;&lt;/ul&gt;
    &lt;button class="cleanup"&gt;Clear complete&lt;/button&gt;
&lt;/div&gt;</code></pre>
</div>
				
			<p>There are four components used within this application, including:</p>
			
			<ul>
				<li><tt>TodoItemModel</tt> : this is a native Backbone model used to store the data required for each individual todo; in this example, each todo item has a <tt>todo</tt> caption, and a <tt>complete</tt> status.</li>
				<li><tt>TodoItemView</tt> : this is an Epoxy view used for the display of each individual todo list item. This view constructs a DOM fragment with a checkbox and text input, and then binds those elements' values to the view's model. In addition, the view adds a few extra binding handlers to help manage the view: the <tt>readonly:</tt> handler toggles the text input's <tt>"readonly"</tt> property, and the <tt>save:</tt> binding is used used to call <b>save</b> on the bound model after elements are changed.</li>
				<li><tt>TodosCollection</tt> : this is a native Backbone collection used to manage our active list of todos. It cites <tt>TodoItemModel</tt> as its model constructor, and <tt>TodoItemView</tt> as its view constructor. Remember, a collection must specify a <b>view</b> constructor property in order to work with Epoxy's <tt>collection:</tt> binding.</li>
				<li><tt>TodoAppView</tt> : finally, this Epoxy view manages the main application container view. It uses native Backbone <tt>events</tt> to setup the application's primary controls used to add and remove items from the <tt>TodosCollection</tt> instance. It also applies an Epoxy <tt>collection:</tt> binding to the view's default collection source (referenced as <tt>$collection</tt>).</li>
			</ul>
			
			<p>This application certainly did not require data binding to make it work. In fact, data binding is generally overkill for most common application scenarios. Keep that in mind while assessing the goals and objectives of your projects... Ironically, the author of this library is a very reserved advocate of data binding: while data binding is a great tool that can work wonders at the moments when you need it, it should NOT be considered an automatic choice approach for setting up an interface.</p>
			
			
			<div class="footer">
				<p>Epoxy.js for Backbone is available in a <a href="https://github.com/gmac/backbone.epoxy">GitHub Repo</a>.<br>
					&copy; 2013 Greg MacWilliam (<a href="https://twitter.com/gmacwilliam">@gmacwilliam</a>), a project of <a href="http://www.threespot.com">Threespot</a>.</p>
			</div>
		</div>
	</div>
	<script src="../lib/jquery.js"></script>
	<script src="../lib/underscore.js"></script>
	<script src="../lib/backbone.js"></script>
	<script src="../lib/backbone-localstorage.js"></script>
	<script src="../backbone.epoxy-model.js"></script>
	<script src="../backbone.epoxy-view.js"></script>
	<script src="js/global.js"></script>
</body>
</html>