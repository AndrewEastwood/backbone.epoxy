<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Epoxy.js : Elegant Data Binding for Backbone : Documentation</title>

	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="Epoxy is an elegant and extensible data binding library for Backbone.js designed to hook view elements directly to data models.">
	<meta name="author" content="Greg MacWilliam">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="apple-mobile-web-app-title" content="Epoxy.js">
	<meta name="application-name" content="Epoxy.js">
	
	<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
	<link rel="icon" href="favicon.ico" type="image/x-icon">
	<link href="style/reset.css" rel="stylesheet">
	<link href="style/screen.css" rel="stylesheet">
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-39215101-1']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>
</head>
<body>
	<div id="page">
		<div class="banner clearfix" role="banner">
			<p class="title"><span><b>Epoxy</b>.js</span> Elegant Data Binding for Backbone</p>
			<div class="download">
				<a href="js/backbone.epoxy.min.js" class="download-button">Download Epoxy 0.9.0</a>
				<p class="download-info">8k min, 3k gzip <i>|</i> <a href="https://github.com/gmac/backbone.epoxy">GitHub Full Source</a></p>
			</div>
		</div>
		<div class="navigation" role="navigation">
			<ul class="nav-main clearfix">
				<li><a href="index.html">About Epoxy.js</a></li>
				<li><a href="tutorials.html">Getting Started</a></li>
				<li class="active"><a href="documentation.html">Documentation</a></li>
			</ul>
			<div class="nav-toc">
				<div class="nav-toc-content">
					<b><a href="#model">Epoxy.Model</a></b>
					<ul>
						<li><b><a href="#model-extend">extend</a></b></li>
						<li><b><a href="#model-constructor">constructor</a></b></li>
						<li><a href="#model-add-computed">addComputed</a></li>
						<li><a href="#model-add-observable">addObservable</a></li>
						<li><a href="#model-clear-observables">clearObservables</a></li>
						<li><a href="#model-computeds">computeds</a></li>
						<li><a href="#model-destroy">destroy</a></li>
						<li><a href="#model-get">get</a></li>
						<li><a href="#model-get-copy">getCopy</a></li>
						<li><a href="#model-has-observable">hasObservable</a></li>
						<li><a href="#model-modify-array">modifyArray</a></li>
						<li><a href="#model-modify-object">modifyObject</a></li>
						<li><a href="#model-observable-defaults">observableDefaults</a></li>
						<li><a href="#model-remove-observable">removeObservable</a></li>
						<li><a href="#model-set">set</a></li>
					</ul>
			
					<b><a href="#view">Epoxy.View</a></b>
					<ul>
						<li><b><a href="#view-extend">extend</a></b></li>
						<li><b><a href="#view-constructor">constructor</a></b></li>
						<li><b><a href="#view-binding-context">binding context</a></b></li>
						<li><a href="#view-apply-bindings">applyBindings</a></li>
						<li><a href="#view-binding-handlers">bindingHandlers</a></li>
						<li><a href="#view-bindings">bindings</a></li>
						<li><a href="#view-binding-sources">bindingSources</a></li>
						<li><a href="#view-remove">remove</a></li>
						<li><a href="#view-remove-bindings">removeBindings</a></li>
					</ul>
			
					<b><a href="#binding-handlers">View Binding Handlers</a></b>
					<ul>
						<li><a href="#handler-attr">attr</a></li>
						<li><a href="#handler-checked">checked</a></li>
						<li><a href="#handler-class-name">className</a></li>
						<li><a href="#handler-collection">collection</a></li>
						<li><a href="#handler-css">css</a></li>
						<li><a href="#handler-disabled">disabled</a></li>
						<li><a href="#handler-enabled">enabled</a></li>
						<li><a href="#handler-events">events</a></li>
						<li><a href="#handler-html">html</a></li>
						<li><a href="#handler-text">text</a></li>
						<li><a href="#handler-toggle">toggle</a></li>
						<li><a href="#handler-value">value</a></li>
					</ul>
			
					<b><a href="#binding-operators">View Binding Operators</a></b>
					<ul>
						<li><a href="#operator-all">all</a></li>
						<li><a href="#operator-any">any</a></li>
						<li><a href="#operator-format">format</a></li>
						<li><a href="#operator-length">length</a></li>
						<li><a href="#operator-none">none</a></li>
						<li><a href="#operator-not">not</a></li>
						<li><a href="#operator-select">select</a></li>
					</ul>
				</div>
			</div>
		</div>
		<div class="main" role="main">
			<h1>Documentation</h1>
			
			<div class="section">
				<h2 id="model">Epoxy.Model</h2>
			
				<p>The Epoxy Model object extends <tt>Backbone.Model</tt>, providing a new model abstract to be extended into your application.</p>

				<p>The Epoxy model introduces observable attributes on top of Backbone's native model attributes. Observable attributes are virtualized properties of the model: they may be <b>get</b> and <b>set</b> just like normal model attributes, and will trigger <tt>"change"</tt> events on the model when modified, however they do not exist within the model's <b>attributes</b> table, nor will they be saved with model data. Observable model attributes exist only in memory for the lifespan of a model instance. The goal of observable attributes is to provide an intermediary layer between a model's data and its display; allowing stateful view data (such as view selection states) to be managed within the model, yet not be retained by data stores.</p>

				<p>Additionally, Epoxy's observable attributes may be <i>computed</i>. Computed attributes operate as accessors and mutators, where a computed attribute will <b>get</b> an assembled value derived from other model attributes, and will <b>set</b> one more more mutated values derived from an input. Computed observables bind themselves to their dependency model attributes and will update themselves in response to any of their dependencies changing, then in turn trigger their own <tt>"change:attributeName"</tt> event on the model.</p>
			</div>
			<div class="section">
				<h3 id="model-extend">extend</h3>
				<code>Backbone.Epoxy.Model.extend(properties, [classProperties])</code>
				<p>Extends the <tt>Epoxy.Model</tt> constructor for use in your own implementation.</p>
			</div>
			
			<div class="section">
				<h3 id="model-constructor">constructor</h3>
				<code>new Backbone.Epoxy.Model([attributes], [options])</code>
				<p>Creates a new <tt>Epoxy.Model</tt> instance.</p>
			</div>
			
			<div class="section">
				<h3 id="model-add-observable">addObservable</h3>
				<code>model.addObservable(name, value)</code>
				<p>Adds an observable attribute to the model. Observable attributes are virtualized properties of the model: they may be <b>get</b> and <b>set</b> just like normal model attributes, and will trigger <tt>"change"</tt> events on the model when modified, however they do not exist within the model's <b>attributes</b> table, nor will they be saved with model data. Observable model attributes exist only in memory for the lifespan of a model instance. The goal of observable attributes is to provide an intermediary layer between a model's data and its display; allowing stateful view data (such as view selection states) to be managed within the model, yet not be retained by data stores.</p>

				<p>Observable attributes may store any type of data, and will trigger normal <tt>"change:attributeName"</tt> events when set through the model's standard <b>set</b> method.</p>
				
				<p>Observable attributes storing object values (<tt>Object</tt> or <tt>Array</tt>) will trigger <tt>"change"</tt> events in response to changes in object composition, rather than object identity (this differs from the base Backbone Model, which will only trigger <tt>"change"</tt> events when a unique object instance replaces another within the model). Object comparison checks are performed using Underscore's <b>isEqual</b> method, which will compare the composition of objects and the contents of arrays. Performance should be considered when managing large objects.</p>
				
<pre><button class="run">Run</button><code class="js">var model = new Backbone.Epoxy.Model();
model.addObservable("isSelected", false);
alert( model.get("isSelected") );</code>	
</pre>
				<p>Use the <b><a href="#model-observable-defaults">observableDefaults</a></b> hash to automatically construct observables on your model instances.</p>
			</div>
			
			<div class="section">
				<h3 id="model-add-computed">addComputed</h3><br>
				<code>model.addComputed(name, params) or...</code><br>
				<code>model.addComputed(name, getter, [setter], [*deps])</code>
				<p>Adds a computed observable attribute to the model. Computed attributes operate as accessors and mutators, where a computed attribute will <b>get</b> an assembled value derived from other model attributes, and will <b>set</b> one more more mutated values derived from an input. Computed observables bind themselves to their dependency attributes and will update themselves in response to any of their dependencies changing, then in turn trigger their own <tt>"change:attributeName"</tt> event on the model.</p>

				<p id="model-computed-params">The <b>addComputed</b> method is called with an attribute name and a params object defining the following:</p>
				
				<ul>
					<li><b>get:</b> <i>Required function; invoked in context of the model</i>. This getter function assembles its value based on other model properties (attributes, observables, or other computeds), then returns the generated value. Note that a getter function should always reference other model values using the model's <b>get</b> method (for <a href="#model-computed-deps">automatic dependency mapping</a>).</li>
                    
					<li><b>[deps]:</b> <i>Optional array</i>. An array of attribute names that the getter function depends on. This manual property mapping is only required if your getter contains unreachable values that would be missed by automatic dependency mapping (discussed below).</li>
                    					
					<li><b>[set]:</b> <i>Optional function; invoked in context of the model</i>. A mutator function which receives a raw input value, and returns an object defining new key/value pairs to be merged into the model. Computed observables declared without a <b>set</b> function are read-only.</li>
				</ul>
				
				<p>Note that the <b>get</b> and <b>set</b> functions are invoked in the context of their parent model, so referencing <tt>this</tt> within their scopes refers to the model.</p>
				
<pre><button class="run">Run</button><code class="js">var model = new Backbone.Epoxy.Model({price:100});
model.addComputed("formattedPrice", {
    deps: ["price"],
    get: function() {
        return "$"+ this.get("price");
    },
    set: function( value ) {
        return {price: parseInt(value.replace("$", ""))}
    }
});

alert( model.get("formattedPrice") ); // '$100'
model.set("formattedPrice", "$150");
alert( model.get("price") ); // 150</code>	
</pre>
				
				<p><b id="model-computed-deps">Automatic Dependency Mapping</b></p>
				<p>In the above example, <tt>["price"]</tt> is manually declared as a dependency of the computed getter (meaning the getter will need to update itself when <tt>"price"</tt> changes). While this manual declaration is a nice safety net, we could also exclude the <tt>"deps"</tt> param entirely in this case thanks to Epoxy's automatic dependency mapping.</p>
				
				<p>Automatic dependency mapping works using the <b>get</b> method wrapper of the <tt>Epoxy.Model</tt>. While generating a computed attribute's initial value, the <tt>Epoxy.Model</tt> registers all attribute names requested from <i>all</i> <tt>Epoxy.Model</tt> instances, and binds the computed attribute accordingly. Automatic mapping works great given the following:</p>
				
				<ul>
					<li>All model references (the parent model, or others) are instances of <tt>Epoxy.Model</tt>.</li>
					<li>All model attributes are accessed using their model's <b>get</b> method.</li>
					<li>All <b>get</b> calls are free of conditional logic (keep reading...)</li>
				</ul>
				
				<p>Regarding conditional <b>get</b> calls: this situation may create unreachable getters that cannot be automatically mapped. Consider the following BROKEN example:</p>
				
<pre>
<code class="js">var model = new Backbone.Epoxy.Model({
    shortName: "Luke",
    fullName: "Luke Skywalker",
    active: false
});

// BROKEN:
model.addComputed("displayName", function() {
    return this.get("active") ? this.get("fullName") : this.get("shortName");
});</code>	
</pre>
				<p>See the error in the above example? The <tt>"fullName"</tt> and <tt>"shortName"</tt> attributes are accessed conditionally, therefore one will be unreachable while mapping dependencies. To fix this, we could either manually declare dependencies, or else <b>get</b> all dependencies as local variables prior to conditional logic, like so:</p>
				
<pre>
<code class="js">// FIXED:
model.addComputed("displayName", function() {
    var fullName = this.get("fullName");
    var shortName = this.get("shortName");
    return this.get("active") ? fullName : shortName;
});</code>	
</pre>
				<p>Use the <b><a href="#model-computeds">computeds</a></b> hash to automatically construct computed observables on your model instances.</p>
			</div>
			
			<div class="section">
				<h3 id="model-clear-observables">clearObservables</h3>
				<code>model.clearObservables()</code>
				<p>Removes all observable properties on the model and cleans up their bound events. Cleared observables will no longer exist on the model, so will no longer be accessible or trigger events. Be sure to call <b>clearObservables</b> when deprecating an Epoxy model without specifically calling its <b>destroy</b> method.</p>
			</div>
			
			<div class="section">
				<h3 id="model-computeds">computeds</h3>
				<code>model.computeds</code>
				<p>A hash table declaring computed observable attributes to be automatically added to a model instance by the constructor. Uses <b><a href="#model-add-computed">addComputed</a></b> to create observable attributes. Computed observables may be declared with a <a href="#model-computed-params">computed params</a> object, or as a getter function (uses <a href="#model-computed-deps">automatic dependency mapping</a>).</p>	
<pre>
<code class="js">var ComputedModel = Backbone.Epoxy.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    },
    computeds: {
        fullNameParams: {
            deps: ["firstName", "lastName"],
            get: function() {
                return this.get("firstName") +" "+ this.get("lastName");
            },
            set: function( value ) {
                var first = value.split(" ")[0];
                var last = value.split(" ")[1];
                return {firstName: first, lastName: last};
            }
        },
        fullNameGetter: function() {
            return this.get("firstName") +" "+ this.get("lastName");
        }
    }
});</code>
</pre>
			</div>
			
			<div class="section">
				<h3 id="model-destroy">destroy</h3>
				<code>model.destroy([options])</code>
				<p>Override wrapper for the Backbone Model's native <b>destroy</b> method. This wrapper cleans up Epoxy model configuration, then defers to the Backbone Model's native <b>destroy</b> method. If you'd like to clean up a model without completely destroying it, use the <b>clearObservables</b> method.</p>
			</div>
			
			<div class="section">
				<h3 id="model-get">get</h3>
				<code>model.get(attribute)</code>
				<p>Override wrapper for the Backbone Model's native <b>get</b> method. This override allows basic model attributes and Epoxy observable/computed attributes to be accessed through a common API.</p>
				<p>The Epoxy <b>get</b> method will first check for an observable attribute, then defers to the Backbone Model's native <b>get</b> method if no observable was found. Remember that an observable attribute overrides a native attribute with the same name, so be mindful of naming collisions.</p>
			</div>
			
			<div class="section">
				<h3 id="model-get-copy">getCopy</h3>
				<code>model.getCopy(attribute)</code>
				<p>Gets a model attribute value (native, observable, or computed), and performs a shallow copy on any non-primitive values returned. This is useful for getting copies of <tt>Object</tt> and <tt>Array</tt> values that you plan to modify outside of the model, then resubmit with changes (remember that <tt>"change"</tt> events only trigger for non-primitive values when their identity changes). The <b><a href="#model-modify-array">modifyArray</a></b> and <b><a href="#model-modify-object">modifyObject</a></b> methods may also be used to perform object changes internally within the model.</p>
			</div>
			
			<div class="section">
				<h3 id="model-has-observable">hasObservable</h3>
				<code>model.hasObservable(attribute)</code>
				<p>Returns <tt>true</tt> if the model has an observable or computed observable attribute with the specified name. Note that the Backbone Model's native <b>has</b> method is NOT modified by Epoxy, so will still only report on the presence of Backbone-native model attributes.</p>
			</div>
			
			<div class="section">
				<h3 id="model-modify-array">modifyArray</h3>
				<code>model.modifyArray(attribute, arrayMethod, [*args])</code>
				<p>Performs an internal update on a stored <tt>Array</tt> model attribute (native or observable) using a standard JavaScript array modifier (<tt>pop</tt>, <tt>push</tt>, <tt>reverse</tt>, <tt>shift</tt>, <tt>slice</tt>, <tt>sort</tt>, <tt>splice</tt>, and <tt>unshift</tt>), then triggers a change event for the modified model attribute. Invoke with the model attribute name to modify, a string of the array method name to call, and any additional arguments to be passed into the array method. Returns any results from the array method. Calling <b>modifyArray</b> on a non-array attribute will take no action.</p>
				
<pre><button class="run">Run</button><code class="js">var model = new Backbone.Epoxy.Model({wordList:[]});
model.modifyArray("wordList", "push", "deathstar");
alert( model.get("wordList").length );</code>	
</pre>
			</div>

			<div class="section">
				<h3 id="model-modify-object">modifyObject</h3>
				<code>model.modifyObject(attribute, objectProperty, value)</code>
				<p>Performs an internal update on a stored <tt>Object</tt> model attribute (native or observable), then triggers a change event for the modified model attribute. Invoke with the model attribute name to modify, a property name to set on the object, and a value to set as the object property. Setting <tt>undefined</tt> to a property will delete it from the object. Returns the modified object. Calling <b>modifyObject</b> will only take action on model attributes with an assessed type of <tt>"object"</tt>.</p>
				
<pre><button class="run">Run</button><code class="js">var model = new Backbone.Epoxy.Model({ wordsDict:{} });
model.modifyObject("wordsDict", "deathstar", true);
alert( model.get("wordsDict").hasOwnProperty("deathstar") );</code>	
</pre>
			</div>
			
			<div class="section">
				<h3 id="model-observable-defaults">observableDefaults</h3>
				<code>model.observableDefaults</code>
				<p>A hash table declaring observable attributes to be automatically added to a model instance by the constructor. Uses <b><a href="#model-add-observable">addObservable</a></b> to create the specified observable attributes. After a model instance has been constructed, observable values are managed through the model's <b>get</b> and <b>set</b> methods. Any observable values declared as a function will be invoked while getting added to the model; this is useful for creating unique Object/Array values for each model instance.</p>
<pre>
<code class="js">var ComputedModel = Backbone.Epoxy.Model.extend({
    observableDefaults: {
        isSelected: false,
        keysList: function() { return ["a", "b"]; }
    }
});</code>
</pre>	
			</div>
			
			<div class="section">
				<h3 id="model-remove-observable">removeObservable</h3>
				<code>model.removeObservable(attribute)</code>
				<p>Removes an observable attribute by name, and cleans up all bound listeners. A removed observable property will no longer exist within the model, so may no longer be accessed or trigger events.</p>
			</div>
			
			<div class="section">
				<h3 id="model-set">set</h3>
				<code>model.set(attributes, [options])</code>
				<p>Override wrapper for the Backbone Model's native <b>set</b> method. This override allows basic model attributes and Epoxy observable/computed attributes to be accessed through a common API.</p>
				<p>The Epoxy <b>set</b> method will first check for an observable attribute, then defers to the Backbone Model's native <b>set</b> method if no observable was found. Remember that an observable attribute overrides a native attribute with the same name, so be mindful of naming collisions.</p>
			</div>
			
			<div class="section">
				<h2 id="view">Epoxy.View</h2>

				<p>The Epoxy View object extends <tt>Backbone.View</tt>, providing a new view abstract to be extended into your application.</p>

				<p>The Epoxy View provides elegant and extensible hooks for binding a data source (<tt>Backbone.Model</tt> and/or <tt>Backbone.Collection</tt> instances) directly to DOM elements. When data attributes change, they will automatically trigger refresh of all bound view elements; seamlessly updating the view without requiring a complete render pass.</p>

				<p>Also note that an Epoxy view may bind to a native <tt>Backbone.Model</tt> instance, or to an <tt>Epoxy.Model</tt> with specialized observable attributes. Because both model types operate with a common API, the Epoxy View does not depend on its <tt>Epoxy.Model</tt> counterpart to support model bindings. Therefore, you're free to exclude <tt>Epoxy.Model</tt> resources from your project if you just want view binding features.</p>
			</div>
			
			<div class="section">
				<h3 id="view-extend">extend</h3>
				<code>Backbone.Epoxy.View.extend(properties, [classProperties])</code>
				<p>Extends the <tt>Epoxy.View</tt> constructor for use in your own implementation.</p>
			</div>
			
			<div class="section">
				<h3 id="view-constructor">constructor</h3>
				<code>new Backbone.Epoxy.View([options])</code>
				<p>Creates a new <tt>Epoxy.View</tt> instance.</p>
			</div>
			
			<div class="section">
				<h3 id="view-binding-context">binding context</h3>
				<code>{$model:model, $collection:collection, [*attributes]}</code>
				<p>To establish bindings, an Epoxy view generates a <i>binding context</i> with routes pointing to all available <i>data sources</i> and their attributes. Data sources are instances of <tt>Backbone.Model</tt> and/or <tt>Backbone.Collection</tt> that provide themselves and their attributes to the view for binding. By default, an Epoxy view looks for two potential data sources: the view's <b>model</b> property, and its <b>collection</b> property. References to these data sources are automatically configured in the binding context as <tt>$model</tt> and <tt>$collection</tt>. Aliases to all <tt>$model</tt> attributes are also created.</p>
				<p>Additional <tt>Model</tt> and <tt>Collection</tt> data sources may be added to the binding context using the <b><a href="#view-binding-sources">bindingSources</a></b> property.</p>
			</div>
			
			<div class="section">
				<h3 id="view-apply-bindings">applyBindings</h3>
				<code>view.applyBindings()</code>
				<p>Removes any existing view bindings, then applies all bindings defined within the view's <b>bindings</b> object. All bindings are established using the view's <b>$el</b> as the display target, and the view's <b>model</b>, <b>collection</b>, and/or <b>bindingSources</b> properties as the data sources (see <b><a href="#view-binding-context">binding context</a></b> and <b><a href="#view-binding-sources">bindingSources</a></b> for more information). A view with invalid display or data targets will apply no bindings. If the <b>bindings</b> object is a string, that string will be used as an attribute selector query for extracting bindings from the view's <b>$el</b> container.</p>

				<p>The <b>applyBindings</b> method is automatically called by the view constructor <i>after</i> the view's <b>initialize</b> method runs. This allows the <b>initialize</b> step to make adjustments within the view prior to bindings being applied. You generally shouldn't need to call <b>applyBindings</b> manually.</p>

				<p>Also note that view bindings are baked at the time they are applied. All relationships between data sources and the view are established during this binding step and can only be reconfigured by unbinding and rebinding the view.</p>
			</div>
			
			<div class="section">
				<h3 id="view-binding-handlers">bindingHandlers</h3>
				<code>view.bindingHandlers</code>
				<p>A hash table defining a view's custom binding handlers. Binding handlers are used to interchange model data with elements in the view. While Epoxy includes a <a href="#binding-handlers">core set</a> of basic binding handlers for managing an element's content and formatting, developers are encouraged to extend their views with customized binding handlers.</p>
					
				<p>To declare binding handlers, define a new property on the <b>bindingHandlers</b> hash with a params object defining <b>set</b> and <b>get</b> function properties:</p>

<pre>
<code class="js">var BindingView = Backbone.Epoxy.View.extend({
    bindingHandlers: {
        printList: {
            set: function( $element, value ) {
                $element.text( value.join(",") );
            },
            get: function( $element, value ) {
                return $element.text().split(",");
            }
        }
    }
});</code>
</pre>				
				<ul>
					<li><b>set:</b> <i>Required function, invoked in context of the binding</i>. This function is used to WRITE data from the model into the view. The <b>set</b> function receives two arguments: a jQuery representation of the bound element, and the model attribute value to be written into the view. The <b>set</b> function returns nothing.</li>
					<li><b>[get]:</b> <i>Optional function, invoked in context of the binding</i>. This function is used to READ data from the view to be sent to the model. The <b>get</b> function receives two arguments: a jQuery representation of the bound element, and the current model attribute value to be changed (useful when modifying objects). The <b>get</b> function should return a value to replace the current bound model attribute. When modifying <tt>Object</tt> and <tt>Array</tt> values, be sure to make changes to a <i>copy</i> of the current value, then submit that back to the model.</li>
				</ul>
				
				<!--p>Note that the <b>get</b> and <b>set</b> functions are invoked in the context of their parent view, so referencing <tt>this</tt> within their scopes refers to the view.</p-->
				
				<p>While declaring a display-only binding handler (one-way binding), you may declare its setter function directly on the <b>bindingHandlers</b> hash:</p>

<pre>
<code class="js">var BindingView = Backbone.Epoxy.View.extend({
    bindingHandlers: {
        printList: function( $element, value ) {
            $element.text( value.join(",") );
        }
    }
});</code>
</pre>
			</div>
						
			<div class="section">
				<h3 id="view-bindings">bindings</h3>
				<code>view.bindings</code>
				<p>A hash declaring the view's element-to-attribute binding scheme, or a string defining an element attribute to query from the view's DOM. All bindings are established using the view's <b>$el</b> reference as the display target, and the view's <b>model</b> reference as the data target. A view missing its <b>$el</b> and/or <b>model</b> properties will apply no bindings.</p>
				
				<p>The bindings hash syntax keeps all binding declarations within the view. The <b>bindings</b> object declares a set of key/value pairs, where the key defines an element query, and the value defines the element's model bindings:</p>
<pre>
<code class="js">var BindingModel = Backbone.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    }
});
	
var BindingView = Backbone.Epoxy.View.extend({
    model: new BindingModel(),
    bindings: {
        "input.first-name": "value:firstName,events:['keyup']",
        "input.last-name": "value:lastName,events:['keyup']"
    }
});</code>
</pre>
				<p>Alternatively, you may choose to follow the popular convention of declaring bindings directly within the DOM using element attributes, at which time the <b>bindings</b> property should define the attribute name to query for. Epoxy specifies <tt>"data-bind"</tt> by default. All philosophical opinions aside, this technique works just as well as view-based declarations. Getting into philosophy, this method creates a bizarre (albeit handy) relationship between JavaScript mechanics and raw display. Ultimately, the choice is yours as to which method works best for your purposes.</p>

<pre>
<code class="js">var BindingModel = Backbone.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    }
});

var BindingView = Backbone.Epoxy.View.extend({
    el: "#binding-view"
    model: new BindingModel(),
    bindings: "data-bind"
});

&lt;div id="binding-view"&gt;
    &lt;p&gt;First: &lt;input type="text" data-bind="value:firstName,events:['keyup']"&gt;&lt;/p&gt;
    &lt;p&gt;Last: &lt;input type="text" data-bind="value:lastName,events:['keyup']"&gt;&lt;/p&gt;
&lt;/div&gt;</code>
</pre>
			</div>
			
			<div class="section">
				<h3 id="view-binding-sources">bindingSources</h3>
				<code>view.bindingSources</code>
				<p class="draft">This API is a working draft. Implementation may change.</p>
				<p>A hash table defining additional binding sources to be added to the view's binding context. Binding sources are instances of <tt>Backbone.Model</tt> and/or <tt>Backbone.Collection</tt>. By default, an Epoxy view configures two potential binding sources: the view's <b>model</b> and <b>collection</b> properties are automatically added to the binding context under the aliases <tt>$model</tt> and <tt>$collection</tt>. Additional model and collection data sources may be specified within the <b>bindingSources</b> hash; these additional data sources will be added into the binding context under the alias <tt>$sourceName</tt>.</p>

				<p>Additionally, model data sources provide aliases to all of their attributes within the binding context. In the case of the default <tt>$model</tt> data source, all model attributes are aliased within the binding context using their normal <tt>attribute</tt> name. For additional model sources added through the <b>bindingSources</b> hash, model attributes are added under the alias <tt>source_attributeName</tt>. This avoids attribute naming conflicts while binding multiple models of the same type.</p>

<pre>
<code class="js">// Epoxy view specifying five data sources:
var BindingView = Backbone.Epoxy.View.extend({
    model: new Backbone.Model({name: "Luke Skywalker"}),
    collection: new Backbone.Collection(),
    bindingSources: {
        han: new Backbone.Model({name: "Han Solo"}),
        obiwan: new Backbone.Model({name: "Obi-Wan Kenobi"}),
        users: new Backbone.Collection()
    }
});

// Resulting binding context (psudocode):
{
    $model: &lt;Backbone.Model&gt;,
    $collection: &lt;Backbone.Collection&gt;,
    $han: &lt;Backbone.Model&gt;,
    $obiwan: &lt;Backbone.Model&gt;,
    $users: &lt;Backbone.Collection&gt;,
    name: &lt;$model:name&gt;,
    han_name: &lt;$han:name&gt;,
    obiwan_name: &lt;$obiwan:name&gt;
}
</code>
</pre>
			</div>
			
			<div class="section">
				<h3 id="view-remove">remove</h3>
				<code>view.remove()</code>
				<p>Override wrapper for the Backbone Views's native <b>remove</b> method. This override calls <b>removeBindings</b>, then defers to the Backbone View's native <b>remove</b> method.</p>
			</div>
			
			<div class="section">
				<h3 id="view-remove-bindings">removeBindings</h3>
				<code>view.removeBindings()</code>
				<p>Removes and cleans up all bindings applied to the view. All binding hooks will be nullified, leaving the view's DOM elements formatted in their final bound state. The <b>removeBindings</b> method is automatically called with the <b>remove</b> method. Be mindful that you should manually call <b>removeBindings</b> when deprecating an Epoxy view without specifically calling its <b>remove</b> method.</p>
			</div>
			
			<div class="section">
				<h2 id="binding-handlers">View Binding Handlers</h2>
				<p>Binding handlers are used to interchange model data with elements in the view. The Epoxy <tt>View</tt> includes default binding handlers for common tasks such as managing a bound element's content, class, and style. However, don't feel limited to just Epoxy's out-of-the-box binding handlers. You may easily <a href="#view-binding-handlers">define your own binding handlers</a> within a view.</p>
				
				<p>One or more binding handlers may be applied to an element as a comma-separated properties list (here shown using DOM attribute bindings):</p>

<pre>
<code class="html">&lt;a data-bind="text:linkText,attr:{href:linkUrl,title:linkText}"&gt;&lt;/a&gt;</code>
</pre>
				<p>In the above example, <tt>"text:"</tt> and <tt>"attr:"</tt> are binding handlers, while <tt>"linkText"</tt> and <tt>"linkUrl"</tt> are the bound model attributes assigned to them. In the case of the <tt>"attr"</tt> handler, its value is a hash of attribute names, each with an associated model value.</p>
				
				<p>Be aware that binding declarations are parsed as JavaScript <tt>Object</tt> bodies, therefore a binding declaration <i>must</i> conform to proper JavaScript syntax. To give due credit, Epoxy's binding system is modeled after the clever technique used in <a href="http://knockoutjs.com/">Knockout.js</a>. However, Epoxy deliberately limits some of Knockout's free-form binding allowances, such as inline concatenation (which becomes overly technical within the presentation layer, IMHO). If you're coming from Knockout, don't expect to write as much inline binding JavaScript.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-attr">attr</h3>
				<span class="alias">read-only</span>
				<code>data-bind="attr:{name:modelAttribute,'data-name':modelAttribute}"</code>
				<p>Binds model attribute values to a list of element attributes. Attribute bindings are defined as a hash of key/value pairs, where each key defines an element attribute and the model reference defines the attribute value. Attribute keys may be defined as strings.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-checked">checked</h3>
				<span class="alias">read-write</span>
				<code>data-bind="checked:modelAttribute"</code>
				<p>Binds <tt>checkbox</tt> and <tt>radio</tt> elements to the model. The binding behavior differs slightly for various element/value combinations:</p>

				<ul>
					<li><b>Radios:</b> a bound <tt>radio</tt> element will become checked when the element's <tt>value</tt> matches the bound model attribute. Checking a radio will set its <tt>value</tt> to the bound model attribute.</li>

					<li><b>Checkbox arrays:</b> when a <tt>checkbox</tt> element is bound to an <tt>Array</tt> model attribute, the element will be checked while its <tt>value</tt> exists within the value array, and unchecked while its <tt>value</tt> is absent from the array. Likewise, toggling the element's <tt>checked</tt> property will add and remove its value from the bound array. Keep in mind that arrays modified within a native <tt>Backbone.Model</tt> will NOT trigger a <tt>"change"</tt> event unless the array <i>instance</i> is changed. Using an <tt>Epoxy.Model</tt> observable will help here by managing object copies, and by performing array comparisons by content.</li>

				 	<li><b>Checkbox toggles:</b> when a <tt>checkbox</tt> element is bound to a primitive model attribute (types <tt>String</tt>, <tt>Boolean</tt>, or <tt>Number</tt>), the element will be checked based on a loosely-typed assessment of the model attribute's truthiness. When the element's <tt>"checked"</tt> status is toggled, it will submit a <tt>Boolean</tt> value back to the model attribute.</li>
				</ul>
			</div>
			
			<div class="section">
				<h3 id="handler-class-name">classes</h3>
				<span class="alias">read-only</span>
				<code>data-bind="classes:{active:modelAttr,'is-active':modelAttr}"</code>
				<p>Toggles a list of element class names based on the truthiness of their bound model attributes. Class bindings are defined as a hash of key/value pairs, where each key defines a class name and is value references a model attribute that will be loosely-type checked for truthiness; truthy attributes will enable their class, while falsey attributes will disable their class. Class name keys may be defined as strings.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-collection">collection</h3>
				<span class="alias">read-only</span>
				<code>data-bind="collection:$collectionSource"</code>
				<p>Manages the display of a <tt>Backbone.Collection</tt>. The bound collection must specify a <tt>Backbone.View</tt> constructor for displaying its models, at which time the <b>collection</b> handler will manage adding, removing, resorting, and resetting a list of those views to synchronize the display of the collection's contents. The <b>collection</b> binding performs discrete view management, where collection models will be assigned a single view instance for their lifespans, rather than re-rendering all collection views in response to changes. You may choose to use an <tt>Epoxy.View</tt> constructor for the display of individual collection items, allowing each collection view item to bind to its respective model.</p>

				<p>The <b>collection</b> binding requires the following setup:</p>

				<ul>
					<li>The binding must target a <tt>Backbone.Collection</tt> data source available within the <b><a href="#view-binding-context">binding context</a></b>. </li>

					<li>The bound collection must have a property called <b>view</b>, which defines a <tt>Backbone.View</tt> constructor for rendering collection items.</li>
				</ul>

<pre class="js"><code class="js">// View for individual collection items:
var ListItemView = Backbone.View.extend({
    tagName: "li",
    initialize: function() {
        this.$el.text( this.model.get("label") );
    }
});

// Collection defining a Model and View:
var ListCollection = Backbone.Collection.extend({
    model: Backbone.Model,
    view: ListItemView
});

// Binding view for list of collection items:
var ListView = Backbone.Epoxy.View.extend({
    el: "&lt;ul data-bind='collection:$collection'&gt;&lt;/ul&gt;",
    initialize: function() {
        this.collection = new ListCollection();
        this.collection.reset([{label: "Luke Skywalker"}, {label: "Han Solo"}]);
    }
});

var view = new ListView();</code></pre>

				<p>For a working demonstration of the <b>collection</b> binding, see the <a href="tutorials.html#epoxy-todos">Epoxy ToDos</a> demo.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-css">css</h3>
				<span class="alias">read-only</span>
				<code>data-bind="css:{color:modelAttribute,'font-size':modelAttribute}"</code>
				<p>Binds a list of CSS styles to model attributes. CSS style bindings are defined as a hash of key/value pairs, where each key defines a CSS style name and the model attribute defines the style's literal value. CSS keys may be defined as strings.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-disabled">disabled</h3>
				<span class="alias">read-only</span>
				<code>data-bind="disabled:modelAttribute"</code>
				<p>Toggles a form element's <tt>"disabled"</tt> property based on a loosely-typed assessment of the bound model attribute's truthiness. A truthy value disables the element (inversion of the <b>enabled</b> handler).</p>
			</div>
			
			<div class="section">
				<h3 id="handler-enabled">enabled</h3>
				<span class="alias">read-only</span>
				<code>data-bind="enabled:modelAttribute"</code>
				<p>Toggles a form element's <tt>"disabled"</tt> status based on a loosely-typed assessment of the bound model attribute's truthiness. A truthy value enables the element (inversion of the <b>disabled</b> handler).</p>
			</div>
			
			<div class="section">
				<h3 id="handler-events">events</h3>
				<span class="alias">read-only</span>
				<code>data-bind="events:['keydown','focus']"</code>
				<p>The <b>events</b> handler is a special binding used to parameterize what DOM events will trigger changes for read-write element bindings. By default, all read-write bindings will subscribe to their bound element's <tt>"change"</tt> event to trigger model updates. You may bind additional DOM event triggers for the element by listing them in the <b>events</b> array.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-html">html</h3>
				<span class="alias">read-only</span>
				<code>data-bind="html:modelAttribute"</code>
				<p>Sets the element's HTML content to the bound model attribute value. Uses the jQuery <b>html</b> method.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-text">text</h3>
				<span class="alias">read-only</span>
				<code>data-bind="text:modelAttribute"</code>
				<p>Sets the element's text content to the bound model attribute value. Uses the jQuery <b>text</b> method.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-toggle">toggle</h3>
				<span class="alias">read-only</span>
				<code>data-bind="toggle:modelAttribute"</code>
				<p>Toggles the element's display based on a loosely-typed assessment of the bound model attribute's truthiness. Uses the jQuery <b>toggle( [boolean] )</b> method.</p>
			</div>
			
			<div class="section">
				<h3 id="handler-value">value</h3>
				<span class="alias">read-write</span>
				<code>data-bind="value:modelAttribute"</code>
				<p>Binds an input element's (<tt>input</tt>, <tt>select</tt>, <tt>textarea</tt>) value to an underlying model attribute. The element will set its <tt>value</tt> to the bound model attribute upon change event triggers (see the <b><a href="#handler-events">events</a></b> handler), and update its <tt>value</tt> when the underlying model attribute changes.</p>
			</div>
			
			<div class="section">
				<h2 id="binding-operators">View Binding Operators</h2>
				<p>Binding operators provide a layer of flexibility for formatting data attributes directly within a binding declaration; they allow values to be formatted for binding-specific implementations:</p>

<pre><code class="html">&lt;span data-bind="toggle:not(firstName)"&gt;Please enter a first name.&lt;/span&gt;</code></pre>
				
				<p>Binding operators may be parameterized with any data attribute available in the <a href="#view-binding-context">binding context</a>, or with primitive values (<tt>String</tt>, <tt>Number</tt>, or <tt>Boolean</tt>). Be aware that you may <strong>NOT</strong> nest binding operators within one another &mdash; this is very deliberate, and a principle on which Epoxy is fairly opinionated: application logic does not belong within a binding declaration. If you need to perform multi-pass value transformations, that work should be done within your model or else in a custom binding handler.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-all">all</h3>
				<code>data-bind="toggle:all(dataAttribute,[...])"</code>
				<p>Assesses one or more data attributes as <tt>true</tt> if <i>all</i> attributes are truthy.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-any">any</h3>
				<code>data-bind="toggle:any(dataAttribute,[...])"</code>
				<p>Assesses one or more data attributes as <tt>true</tt> if <i>any</i> of the attributes are truthy.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-format">format</h3>
				<code>data-bind="text:format('$1 of $2',dataAttribute,dataAttribute)"</code>
				<p>Formats a string with a series of data attribute replacements. Operates the same as string replacement for <tt>RegExp</tt> capture groups, where field insertions are denoted as <tt>"$1,&nbsp;$2,&nbsp;...&nbsp;$n"</tt>. Escape intentional "$n" patterns within the template string as "\$n". Note that the first value insertion index is 1, not 0.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-length">length</h3>
				<code>data-bind="toggle:length(dataAttribute)"</code>
				<p>Returns the length of an <tt>Array</tt> or <tt>Collection</tt> data attribute, or <tt>0</tt> by default. Useful for loosely-typed assessments of a collection's content status.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-none">none</h3>
				<code>data-bind="toggle:none(dataAttribute,[...])"</code>
				<p>Assesses one or more data attributes as <tt>true</tt> if <i>none</i> of the attributes are truthy.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-not">not</h3>
				<code>data-bind="toggle:not(dataAttribute)"</code>
				<p>Inverts the loosely-typed boolean value of a data attribute.</p>
			</div>
			
			<div class="section">
				<h3 id="operator-select">select</h3>
				<code>data-bind="text:select(conditionalValue,truthyValue,falseyValue)"</code>
				<p>Performs a ternary operation using JavaScript's <tt>?:</tt> operator. The <b>select</b> operation receives three arguments: the first argument is assessed as a loosely-typed conditional; if truthy, the second argument is returned; if falsey, the third argument is returned.</p>
			</div>
			
			<div class="footer" role="contentinfo">
				<p>Epoxy.js for Backbone is available on <a href="https://github.com/gmac/backbone.epoxy">GitHub</a>.<br>
					&copy; 2013 Greg MacWilliam (<a href="https://twitter.com/gmacwilliam">@gmacwilliam</a>), a project of <a href="http://www.threespot.com">Threespot</a>.</p>
			</div>
		</div>
	</div>
	<script src="js/jquery.js"></script>
	<script src="js/underscore.js"></script>
	<script src="js/backbone.js"></script>
	<script src="js/backbone.epoxy.min.js"></script>
	<script src="js/global.js"></script>
</body>
</html>