<!DOCTYPE html>
<html lang="en">
<head>
	<title></title>
	<link href="screen.css" rel="stylesheet" media="screen">
</head>
<body>
	<div id="page">
		<div id="toc" class="toc">
			<div class="toc-content">
				<a href="#model">Epoxy.Model</a>
				<ul>
					<li><a href="#model-extend">extend</a></li>
					<li><a href="#model-constructor">constructor</a></li>
					<li><a href="#model-add-computed">addComputed</a></li>
					<li><a href="#model-add-observable">addObservable</a></li>
					<li><a href="#model-clear-observables">clearObservables</a></li>
					<li><a href="#model-computeds">computeds</a></li>
					<li><a href="#model-destroy">destroy</a></li>
					<li><a href="#model-get">get</a></li>
					<li><a href="#model-has-observable">hasObservable</a></li>
					<li><a href="#model-observables">observables</a></li>
					<li><a href="#model-remove-observable">removeObservable</a></li>
					<li><a href="#model-set">set</a></li>
				</ul>
			
				<a href="#view">Epoxy.View</a>
				<ul>
					<li><a href="#view-extend">extend</a></li>
					<li><a href="#view-constructor">constructor</a></li>
					<li><a href="#view-apply-bindings">applyBindings</a></li>
					<li><a href="#view-binding-handlers">bindingHandlers</a></li>
					<li><a href="#view-remove">remove</a></li>
					<li><a href="#view-remove-bindings">removeBindings</a></li>
				</ul>
			
				<a href="#binding-handlers">View Binding Handlers</a>
				<ul>
					<li><a href="#handler-attr">attr</a></li>
					<li><a href="#handler-checked">checked</a></li>
					<li><a href="#handler-class-name">className</a></li>
					<li><a href="#handler-collection">collection</a></li>
					<li><a href="#handler-css">css</a></li>
					<li><a href="#handler-disabled">disabled</a></li>
					<li><a href="#handler-enabled">enabled</a></li>
					<li><a href="#handler-events">events</a></li>
					<li><a href="#handler-html">html</a></li>
					<li><a href="#handler-text">text</a></li>
					<li><a href="#handler-toggle">toggle</a></li>
					<li><a href="#handler-value">value</a></li>
				</ul>
			
				<a href="#binding-operators">View Binding Operators</a>
				<ul>
					<li><a href="#operator-all">all</a></li>
					<li><a href="#operator-any">any</a></li>
					<li><a href="#operator-none">none</a></li>
					<li><a href="#operator-not">not</a></li>
					<li><a href="#operator-format">format</a></li>
				</ul>
			</div>
		</div>
		<div class="main">
			<div class="section">
				<h1 id="model">Epoxy.Model</h1>
			
				<p>The Epoxy Model object extends <tt>Backbone.Model</tt>, providing a new model abstract to be extended into your application.</p>

				<p>The Epoxy model introduces observable attributes on top of Backbone's native model attributes. Observable attributes are virtualized properties of the model: they may be <b>get</b> and <b>set</b> just like normal model attributes, and will trigger <tt>"change"</tt> events on the model when modified, however they do not exist within the model's <b>attributes</b> table, nor will they be saved with model data. Observable model attributes exist only in memory for the lifespan of a model instance. The goal of observable attributes is to provide an intermediary layer between a model's data and its display; allowing stateful view data (such as view selection states) to be managed within the model, yet not be retained by data stores.</p>

				<p>Additionally, Epoxy's observable attributes may be <i>computed</i>. Computed attributes operate as accessors and mutators, where a computed attribute will <b>get</b> an assembled value derived from other model attributes, and will <b>set</b> one more more mutated values derived from an input. Computed observables bind themselves to their dependency model attributes and will update themselves in response to any of their dependencies changing, then in turn trigger their own <tt>"change:attributeName"</tt> event on the model.</p>
			</div>
			<div class="section">
				<b class="header" id="model-extend">extend</b>
				<code>Backbone.Epoxy.Model.extend(properties, [classProperties])</code>
				<p>Extends the <tt>Epoxy.Model</tt> constructor for use in your own implementation.</p>
			</div>
			<div class="section">
				<b class="header" id="model-constructor">constructor</b>
				<code>new Backbone.Epoxy.Model([attributes], [options])</code>
				<p>Creates a new <tt>Epoxy.Model</tt> instance.</p>
			</div>
			<div class="section">
				<b class="header" id="model-add-observable">addObservable</b>
				<code>model.addObservable(name, value)</code>
				<p>Adds an observable attribute to the model. Observable attributes are virtualized properties of the model: they may be <b>get</b> and <b>set</b> just like normal model attributes, and will trigger <tt>"change"</tt> events on the model when modified, however they do not exist within the model's <b>attributes</b> table, nor will they be saved with model data. Observable model attributes exist only in memory for the lifespan of a model instance. The goal of observable attributes is to provide an intermediary layer between a model's data and its display; allowing stateful view data (such as view selection states) to be managed within the model, yet not be retained by data stores.</p>

				<p>Observable attributes may store any type of data, and will trigger normal <tt>"change:attributeName"</tt> events when set through the model's standard <b>set</b> method.</p>
				
				<p>Observable attributes storing object values (<tt>Object</tt> or <tt>Array</tt>) will trigger <tt>"change"</tt> events in response to changes in the object's composition, rather than just its identity (this differs from the base Backbone Model, which will only trigger <tt>"change"</tt> events when a unique object instance replaces another within the model). Object comparison checks are performed using Underscore's <b>isEqual</b> method, which will compare the composition of objects and the contents of arrays. Performance should be considered when storing large objects.</p>
				
<pre><button class="run">Run</button><code>var model = new Backbone.Epoxy.Model();
model.addObservable("isSelected", false);
alert( model.get("isSelected") );</code>	
</pre>
				<p>Use the <b><a href="#model-observables">observables</a></b> hash to automatically construct observables on your model instances.</p>
			</div>
			<div class="section">
				<b class="header" id="model-add-computed">addComputed</b><br>
				<code>model.addComputed(name, params) or...</code><br>
				<code>model.addComputed(name, getter, [setter], [*deps])</code>
				<p>Adds a computed observable attribute to the model. Computed attributes operate as accessors and mutators, where a computed attribute will <b>get</b> an assembled value derived from other model attributes, and will <b>set</b> one more more mutated values derived from an input. Computed observables bind themselves to their dependency attributes and will update themselves in response to any of their dependencies changing, then in turn trigger their own <tt>"change:attributeName"</tt> event on the model.</p>

				<p id="model-computed-params">The <b>addComputed</b> method is called with an attribute name and a params object defining the following:</p>
				
				<ul>
					<li><b>get:</b> <i>Required function; invoked in context of the model</i>. This getter function assembles its value based on other model properties (attributes, observables, or other computeds), then returns the generated value. Note that a getter function should always reference other model values using the model's <b>get</b> method (for <a href="#model-computed-deps">automatic dependency mapping</a>).</li>
                    
					<li><b>[deps]:</b> <i>Optional array</i>. An array of attribute names that the getter function depends on. This manual property mapping is only required if your getter contains unreachable values that would be missed by automatic dependency mapping (discussed below).</li>
                    					
					<li><b>[set]:</b> <i>Optional function; invoked in context of the model</i>. A mutator function which receives a raw input value, and returns an object defining new key/value pairs to be merged into the model. Computed observables declared without a <b>set</b> function are read-only.</li>
				</ul>
				
				<p>Note that the <b>get</b> and <b>set</b> functions are invoked in the context of their parent model, so referencing <tt>this</tt> within their scopes refers to the model.</p>
				
<pre><button class="run">Run</button><code>var model = new Backbone.Epoxy.Model({price:100});
model.addComputed("formattedPrice", {
    deps: ["price"],
    get: function() {
        return "$"+ this.get("price");
    },
    set: function( value ) {
        return {price: parseInt(value.replace("$", ""))}
    }
});

console.log( model.get("formattedPrice") ); // "$100"
model.set("formattedPrice", "$150");
console.log( model.get("price") ); // 150</code>	
</pre>
				
				<p><b id="model-computed-deps">Automatic Dependency Mapping</b></p>
				<p>In the above example, <tt>["price"]</tt> is manually declared as a dependency of the computed getter (meaning the getter will need to update itself when <tt>"price"</tt> changes). While this manual declaration is a nice safety net, we could also exclude the <tt>"deps"</tt> param entirely in this case thanks to Epoxy's automatic dependency mapping.</p>
				
				<p>Automatic dependency mapping works using the <b>get</b> method wrapper of the <tt>Epoxy.Model</tt>. While generating a computed attribute's initial value, the <tt>Epoxy.Model</tt> registers all attribute names requested from <i>all</i> <tt>Epoxy.Model</tt> instances, and binds the computed attribute accordingly. Automatic mapping works great given the following:</p>
				
				<ul>
					<li>All model references (the parent model, or others) are instances of <tt>Epoxy.Model</tt>.</li>
					<li>All model attributes are accessed using their model's <b>get</b> method.</li>
					<li>All <b>get</b> calls are free of conditional logic (keep reading...)</li>
				</ul>
				
				<p>Regarding conditional <b>get</b> calls: this situation may create unreachable getters that cannot be automatically mapped. Consider the following BROKEN example:</p>
				
<pre>
<code>var model = new Backbone.Epoxy.Model({
    shortName: "Luke",
    fullName: "Luke Skywalker",
    active: false
});

// BROKEN:
model.addComputed("displayName", function() {
    return this.get("active") ? this.get("fullName") : this.get("shortName");
});</code>	
</pre>
				<p>See the error in the above example? The <tt>"fullName"</tt> and <tt>"shortName"</tt> attributes are accessed conditionally, therefore one will be unreachable while mapping dependencies. To fix this, we could either manually declare dependencies, or else <b>get</b> all dependencies as local variables prior to conditional logic, like so:</p>
				
<pre>
<code>// FIXED:
model.addComputed("displayName", function() {
    var fullName = this.get("fullName");
    var shortName = this.get("shortName");
    return this.get("active") ? fullName : shortName;
});</code>	
</pre>
				<p>Use the <b><a href="#model-computeds">computeds</a></b> hash to automatically construct computed observables on your model instances.</p>
			</div>
			<div class="section">
				<b class="header" id="model-clear-observables">clearObservables</b>
				<code>model.clearObservables()</code>
				<p>Removes all observable properties on the model and cleans up their bound events. Cleared observables will no longer exist on the model, so will no longer be accessible or trigger events. Be sure to call <b>clearObservables</b> when deprecating an Epoxy model without specifically calling its <b>destroy</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="model-computeds">computeds</b>
				<code>model.computeds</code>
				<p>A hash table declaring computed observable attributes to be automatically added to a model instance by the constructor. Uses <b><a href="#model-add-computed">addComputed</a></b> to create observable attributes. Computed observables may be declared with a <a href="#model-computed-params">computed params</a> object, or as a getter function (uses <a href="#model-computed-deps">automatic dependency mapping</a>).</p>
				
<pre>
<code>var ComputedModel = Backbone.Epoxy.Model.extend({
    defaults: {
        firstName: "Luke",
        lastName: "Skywalker"
    },
    computeds: {
        fullNameParams: {
            deps: ["firstName", "lastName"],
            get: function() {
                return this.get("firstName") +" "+ this.get("lastName");
            },
            set: function( value ) {
                var first = value.split(" ")[0];
                var last = value.split(" ")[1];
                return {firstName: first, lastName: last};
            }
        },
        fullNameGetter: function() {
            return this.get("firstName") +" "+ this.get("lastName");
        }
    }
});</code>
</pre>
			</div>
			<div class="section">
				<b class="header" id="model-destroy">destroy</b>
				<code>model.destroy([options])</code>
				<p>Override wrapper for the Backbone Model's native <b>destroy</b> method. This wrapper cleans up Epoxy model configuration, then defers to the Backbone Model's native <b>destroy</b> method. If you'd like to clean up a model without completely destroying it, use the <b>clearObservables</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="model-get">get</b>
				<code>model.get(attribute)</code>
				<p>Override wrapper for the Backbone Model's native <b>get</b> method. This override allows basic model attributes and Epoxy observable/computed attributes to be accessed through a common API.</p>
				<p>The Epoxy <b>get</b> method will first check for an observable attribute, then defers to the Backbone Model's native <b>get</b> method if no observable was found. Remember that an observable attribute overrides a native attribute with the same name, so be mindful of naming collisions.</p>
			</div>
			<div class="section">
				<b class="header" id="model-has-observable">hasObservable</b>
				<code>model.hasObservable(attribute)</code>
				<p>Returns <tt>true</tt> if the model has an observable or computed observable attribute with the specified name. Note that the Backbone Model's native <b>has</b> method is NOT modified by Epoxy, so will still only report on the presence of Backbone-native model attributes.</p>
			</div>
			<div class="section">
				<b class="header" id="model-observables">observables</b>
				<code>model.observables</code>
				<p>A hash table declaring observable attributes to be automatically added to a model instance by the constructor. Uses <b><a href="#model-add-observable">addObservable</a></b> to create observable attributes.</p>
<pre>
<code>var ComputedModel = Backbone.Epoxy.Model.extend({
    observables: {
        isSelected: false,
        todosList: new Backbone.Collection()
    }
});</code>
</pre>	
			</div>
			<div class="section">
				<b class="header" id="model-remove-observable">removeObservable</b>
				<code>model.removeObservable(attribute)</code>
				<p>Removes an observable attribute by name, and cleans up all bound listeners. A removed observable property will no longer exist within the model, so may no longer be accessed or trigger events.</p>
			</div>
			<div class="section">
				<b class="header" id="model-set">set</b>
				<code>model.set(attributes, [options])</code>
				<p>Override wrapper for the Backbone Model's native <b>set</b> method. This override allows basic model attributes and Epoxy observable/computed attributes to be accessed through a common API.</p>
				<p>The Epoxy <b>set</b> method will first check for an observable attribute, then defers to the Backbone Model's native <b>set</b> method if no observable was found. Remember that an observable attribute overrides a native attribute with the same name, so be mindful of naming collisions.</p>
			</div>
			<div class="section">
				<h1 id="view">Epoxy.View</h1>

				<p>The Epoxy View object extends <tt>Backbone.View</tt>, providing a new view abstract to be extended into your application.</p>

				<p>The Epoxy View provides elegant and extensible hooks for binding a model's attributes directly to DOM elements. When model attributes change, they will automatically trigger refresh of all bound view elements; seamlessly updating your UI without requiring a complete render pass.</p>

				<p>Note that an Epoxy View may bind directly to a native Backbone Model, or to an <tt>Epoxy.Model</tt> with specialized observable attributes. Because both model types operate through a common API, the Epoxy View does not depend on its <tt>Epoxy.Model</tt> counterpart to support model bindings (unless otherwise noted). Therefore, you're free to exclude <tt>Epoxy.Model</tt> resources from your project if you just want view binding features.</p>
			</div>
			<div class="section">
				<b class="header" id="view-extend">extend</b>
				<code>Backbone.Epoxy.View.extend(properties, [classProperties])</code>
				<p>Extends the <tt>Epoxy.View</tt> constructor for use in your own implementation.</p>
			</div>
			<div class="section">
				<b class="header" id="view-constructor">constructor</b>
				<code>new Backbone.Epoxy.View([options])</code>
				<p>Creates a new <tt>Epoxy.View</tt> instance.</p>
			</div>
			<div class="section">
				<b class="header" id="view-apply-bindings">applyBindings</b>
				<code>view.applyBindings()</code>
				<p>Removes any existing view bindings, then applies all bindings defined within the view's <b>bindings</b> object, targeting the view's <b>model</b> object (the <b>model</b> must be a valid <tt>Backbone.Model</tt> instance). If the <b>bindings</b> object is a string, that string will be used as an attribute selector query for extracting bindings from the view container's DOM elements.</p>

				<p>The <b>applyBindings</b> method is automatically called by the view constructor after the view's <b>initialize</b> method runs. This allows the <b>initialize</b> step to make adjustments within the view prior to bindings being applied. You generally shouldn't need to call <b>applyBindings</b> manually.</p>

				<p>Also note that view bindings are baked at the time they are applied. All relationships between the model and the view are established during this binding step, and will NOT update automatically to new configurations. Dynamically adding and removing model attributes and/or view bindings will require the view to be completely unbound, and then rebound.</p>
			</div>
			<div class="section">
				<b class="header" id="view-binding-handlers">bindingHandlers</b>
				<code>view.bindingHandlers</code>
				<p>A hash table defining custom binding handlers. Epoxy is designed to be extensible, and encourages developers to extend the library with their own binding handlers specific to their view. Custom binding handlers should in no way be considered a last resort.</p>

				<p>Binding handlers may be defined as two-way bindings that exchange data back and forth between the model and an input element, or as simple one-way bindings that push model data into any view element.</p>

				<b>Two-way binding:</b>
				<p>To declare a two-way binding, define a new property on the bindingHandlers object that provides a params object with get and set function properties:</p>

				<p>The <b>get</b> function is used to READ data from the view that will be set into the model. The get function receives two params: a jQuery representation of the bound element, and the current model value. The get function should return a revised value that will be set to the bound model field.</p>

				<p>The <b>set</b> function is used to WRITE data from the model into the view. The set function receives two params: a jQuery representation of the bound element, and the model value to be written into the view. The set function returns nothing.</p>

				<p>Note that both the <b>get</b> and <b>set</b> functions will be called in the context of their parent views, so citing <tt>this</tt> within any binding handler function refers to the parent view instance.</p>

				<b>One-way binding:</b>
				<p>One-way bindings work just like two-way bindings, except that they only define a <b>set</b> (WRITE) function. Alternatively, you may choose to simplify the declaration of one-way bindings to just a function property on the <b>bindingHandlers</b> object; the solo function will be automatically configured as a setter:</p>
<pre>
	
</pre>
			</div>
			<div class="section">
				<b class="header" id="view-remove">remove</b>
				<code>view.remove()</code>
				<p>Override wrapper for the Backbone Views's native <b>remove</b> method. This override calls <b>removeBindings</b>, then defers to the Backbone View's native <b>remove</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="view-remove-bindings">removeBindings</b>
				<code>view.removeBindings()</code>
				<p>Removes and cleans up all bindings applied to the view. All binding hooks will be nullified, leaving the view's DOM elements formatted in their final bound state. The <b>removeBindings</b> method is automatically called with the <b>remove</b> method. Be mindful that you should manually call <b>removeBindings</b> when deprecating an Epoxy view without specifically calling its <b>remove</b> method.</p>
			</div>
			<div class="section">
				<h2 id="binding-handlers">View Binding Handlers</h2>
				<p>Binding handlers are used to interchange model data with elements within the view. The <tt>Epoxy.View</tt> comes with a bundle of default binding handlers used for common tasks such as manipulating a bound element's content, class, and style. However, don't feel limited to just using Epoxy's default binding handlers. Epoxy makes a point to allow you to easily <a href="#view-binding-handlers">define your own bindings</a>.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-attr">attr</b>
				<span class="alias">read-only</span>
				<code>data-bind="attr:{attr1:fieldName,attr2:fieldName}"</code>
				<p>Binds model values to a list of element attributes. Attribute bindings are defined as an object of key/value pairs, where each key defines an element attribute and the model reference defines the attribute value.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-checked">checked</b>
				<span class="alias">read-write</span>
				<code>data-bind="checked:fieldName"</code>
				<p>This two-way binding attaches checkbox and radio inputs into the model. The binding behavior differs slightly for different element / value combinations:</p>

				<ul>
					<li><b>Radio buttons:</b> a bound <tt>radio</tt> element will become checked when the element's <tt>value</tt> matches the bound model attribute. Checking a radio will set its <tt>value</tt> to the bound model attribute.</li>

					<li><b>Checkbox array:</b> when a <tt>checkbox</tt> element is bound to an <tt>Array</tt> model attribute, the element will be checked while its <tt>value</tt> exists within the value array, and unchecked while its <tt>value</tt> is absent from the array. Likewise, toggling the element's <tt>checked</tt> property will add and remove its value from the bound array. Keep in mind that arrays modified within a native <tt>Backbone.Model</tt> will NOT trigger a <tt>"change"</tt> event unless the array <i>instance</i> is changed. Using an <tt>Epoxy.Model</tt> observable will help here by getting and setting object copies, and by performing content comparisons of value arrays.</li>

				 	<li><b>Checkbox toggle:</b> when a <tt>checkbox</tt> element is bound to a model primitive (<tt>String</tt>, <tt>Boolean</tt>, <tt>Number</tt>), the element will be checked based on a loosely-typed assessment of the value's truthiness. When the element's <tt>"checked"</tt> status is toggled, it will submit a <tt>Boolean</tt> value back to the model attribute.</li>
				</ul>
			</div>
			<div class="section">
				<b class="header" id="handler-class-name">className</b>
				<span class="alias">read-only</span>
				<code>data-bind="className:{class1:fieldName,class2:fieldName}"</code>
				<p>Toggles a list of element class names based on their bound model values. Class name bindings are defined with an object of key/value pairs, where each key defines a class name and is value references a model attribute that will be loosely-type checked for truthiness; when truthy the class will be enabled, when falsey the class will be disabled.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-collection">collection</b>
				<span class="alias">read-only</span>
				<code>data-bind="collection:observableName"</code>
				<p>The collection handler manages the display of a <tt>Backbone.Collection</tt>. The bound collection defines a <tt>View</tt> for its models, which allows the collection handler to take care of adding, removing, and resorting views to keep the display in sync with the collection. One key feature of the <b>collection</b> binding's view management is that it does NOT perform a full re-render of the collection contents for each change. Instead, the <b>collection</b> binding attempts to retain as much existing view as possible, only adding and removing as needed, and performing optimized element sorts when required. You may choose to use <tt>Epoxy.View</tt> elements for the display of individual collection items, allowing each collection item view to also bind to its model.</p>

				<p>The collection binding requires the following setup:</p>

				<ul>
					<li>The binding view's model must be an instance of <tt>Epoxy.Model</tt>, with the target collection stored as an observable property. This observable wrapper is required for aggregating collection events that will trigger view updates.</li>

					<li>The bound collection must have a property called <b>view</b> which defines a Backbone View constructor for displaying collection items (this mirrors the pattern of a collection's <b>model</b> property defining its Model constructor).</li>
				</ul>

				<p>For a working demonstration of setting up a <b>collection</b> binding, see the Epoxy <a href="#">ToDo demo</a>.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-css">css</b>
				<span class="alias">read-only</span>
				<code>data-bind="css:{color:fieldName1,'font-size':fieldName2}"</code>
				<p>Binds a list of CSS styles to model values. CSS style bindings are defined as an object of key/value pairs, where each key defines a CSS style and the model reference defines the style's literal value.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-disabled">disabled</b>
				<span class="alias">read-only</span>
				<code>data-bind="disabled:fieldName"</code>
				<p>Toggles a form element's <tt>"disabled"</tt> property based on a loosely-typed assessment of the bound model value's truthiness. A truthy value disables the element (inversion of the <b>enabled</b> handler).</p>
			</div>
			<div class="section">
				<b class="header" id="handler-enabled">enabled</b>
				<span class="alias">read-only</span>
				<code>data-bind="enabled:fieldName"</code>
				<p>Toggles a form element's <tt>"disabled"</tt> status based on a loosely-typed assessment of the bound model value's truthiness. A truthy value enables the element (inversion of the <b>disabled</b> handler).</p>
			</div>
			<div class="section">
				<b class="header" id="handler-events">events</b>
				<span class="alias">read-only</span>
				<code>data-bind="events:['event1','event2']"</code>
				<p>The <b>events</b> handler is a special binding used to parameterize what DOM events will trigger changes for read-write element bindings. By default, all settable bindings will subscribe to their bound element's <tt>"change"</tt> event to trigger model updates. You may bind additional DOM event triggers for the element by listing them in the <b>events</b> array.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-html">html</b>
				<span class="alias">read-only</span>
				<code>data-bind="html:fieldName"</code>
				<p>Sets the element's HTML content to the bound model value. Uses the jQuery <b>html</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-text">text</b>
				<span class="alias">read-only</span>
				<code>data-bind="text:fieldName"</code>
				<p>Sets the element's text content to the bound model value. Uses the jQuery <b>text</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-toggle">toggle</b>
				<span class="alias">read-only</span>
				<code>data-bind="toggle:fieldName"</code>
				<p>Toggles the element's display on and off based on a loosely-typed assessment of the bound model value's truthiness. Uses the jQuery <b>toggle( [boolean] )</b> method.</p>
			</div>
			<div class="section">
				<b class="header" id="handler-value">value</b>
				<span class="alias">read-write</span>
				<code>data-bind="value:fieldName"</code>
				<p>Binds an input element's (<tt>input</tt>, <tt>select</tt>, <tt>textarea</tt>) value to an underlying model attribute. The element will set its <tt>value</tt> to the bound model attribute upon change event triggers (see the <b><a href="#handler-events">events</a></b> handler), and update its <tt>value</tt> when the underlying model attribute changes.</p>
			</div>
			<div class="section">
				<h2 id="binding-operators">View Binding Operators</h2>
			</div>
			<div class="section">
				<b class="header" id="operator-all">all</b>
				<code>data-bind="toggle:all(fieldName,fieldName)"</code>
				<p>Assesses one or more model attributes as <tt>true</tt> if <i>all</i> values are truthy.</p>
			</div>
			<div class="section">
				<b class="header" id="operator-any">any</b>
				<code>data-bind="toggle:any(fieldName,fieldName)"</code>
				<p>Assesses one or more model attributes as <tt>true</tt> if <i>any</i> of the values are truthy.</p>
			</div>
			<div class="section">
				<b class="header" id="operator-none">none</b>
				<code>data-bind="toggle:none(fieldName,fieldName)"</code>
				<p>Assesses one or more model attributes as <tt>true</tt> if <i>none</i> of the values are truthy.</p>
			</div>
			<div class="section">
				<b class="header" id="operator-not">not</b>
				<code>data-bind="toggle:not(fieldName)"</code>
				<p>Inverts the loosely-typed boolean value of a model attribute.</p>
			</div>
			<div class="section">
				<b class="header" id="operator-format">format</b>
				<code>data-bind="text:format('$1 of $2',fieldName,fieldName)"</code>
				<p>Formats a string with a series of model value replacements. Operates similar to string replacement from <tt>RegExp</tt> capture groups, where field insertions are denoted as <tt>"$1,&nbsp;$2,&nbsp;...&nbsp;$n"</tt>. Escape intentional "$n" patterns within the base string as "\$n". Note that the first value insertion index is 1, not 0.</p>
			</div>
		</div>
	</div>
	<script src="../lib/jquery.js"></script>
	<script src="../lib/underscore.js"></script>
	<script src="../lib/backbone.js"></script>
	<script src="../backbone.epoxy-model.min.js"></script>
	<script>
		$("button.run").click(function() {
			eval( $(this).parent().find("code").html() );
		});
	</script>
</body>
</html>